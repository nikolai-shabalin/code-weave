12\. Изменение размеров сетки[](#layout-algorithm)
-------------------------------------

В этом разделе определяется алгоритм определения размера сетки, который определяет размер всех [дорожек сетки](#grid-track) и, как следствие, всей сетки.

Каждая дорожка имеет определенные [минимальную](#min-track-sizing-function) и [максимальную](#max-track-sizing-function) [функции размера](#grid-template-rows-track-sizing-function) (которые могут быть одинаковыми). Каждая функция определения размера является либо:

* Фиксированная функция определения размера ([&lt;length&gt;](https://www.w3.org/TR/css-values-3/#length-value "Expands to: advance measure | cap | ch | cm | em | ex | ic | in | lh | mm | pc | pt | px | q | rem | rlh | vb | vh | vi | vmax | vmin | vw") или разрешаемая [&lt;percentage&gt;](https://www.w3.org/TR/css-values-3/#percentage-value)).
* Внутренняя функция определения размера ([min-content](#valdef-grid-template-columns-min-content), [max-content](#valdef-grid-template-columns-max-content), [auto](#grid-placement-auto), [fit-content()](#valdef-grid-template-columns-fit-content)).
* Функция гибкого изменения размера ([&lt;flex&gt;](#typedef-flex "Expands to: fr")).

Алгоритм [grid sizing algorithm](#grid-sizing-algorithm) определяет, как разрешить эти ограничения на размер в используемые размеры дорожек.

### 12.1. Алгоритм определения размеров сетки[](#algo-overview)

Примечание: Размещение всех элементов [сетки](#grid-item), включая [подсетки](#subgrid) и их подэлементы, происходит до определения размера.

1.  Сначала используется алгоритм [track-sizing-sizing-algorithm](#track-sizing-algorithm) для определения размеров [столбцов сетки](#grid-column).

    В этом процессе любой элемент [сетки](#grid-item), который является субсегментом [контейнера сетки](#grid-container) в [inline axis](https://www.w3.org/TR/css-writing-modes-4/#inline-axis), рассматривается как пустой, а его элементы сетки (внуки) рассматриваются как прямые дети контейнера сетки (их прародитель). Эта интроспекция является рекурсивной.

    Элементы, которые подразделяются только по оси [block axis](https://www.w3.org/TR/css-writing-modes-4/#block-axis), и чей [grid container](#grid-container) размер по оси [inline axis](https://www.w3. org/TR/css-writing-modes-4/#inline-axis) зависит от размера его содержимого, также интроспектируются: поскольку размер элемента в этом измерении может зависеть от размера его подсеточных дорожек в другом, вклад размера любого такого элемента в размер столбцов этой сетки (см. [Resolve Intrinsic Track Sizes](https://www.w3.org/TR/css-grid-1/#algo-content)) принимается с учетом того, что размер его дорожек определен только до той же точки в алгоритме определения размера сетки, что и сам этот элемент. Например, при первом проходе через этот шаг элемент будет иметь размеры своих дорожек только на этом первом шаге; если будет вызван второй проход этого шага, то элемент выполнит первый проход через шаги 1-3, а также второй проход этого шага, прежде чем вернет свой размер для рассмотрения при определении размеров столбцов этой сетки. Опять же, эта интроспекция является рекурсивной.

    Если расчет расположения [элемента сетки](#grid-item) на этом шаге зависит от [доступного пространства](https://www.w3.org/TR/css-sizing-3/#available) на [оси блока](https://www.w3.org/TR/css-writing-modes-4/#block-axis), предположите доступное пространство, которое он имел бы, если бы любая строка с [определенной](https://www.w3.org/TR/css-sizing-3/#definite) [функцией максимального размера дорожки](#max-track-sizing-function) имела этот размер, а все остальные строки были бы бесконечными. Если и [контейнер сетки](#grid-container), и все дорожки имеют определенные размеры, также примените [align-content](https://www.w3.org/TR/css-align-3/#propdef-align-content), чтобы найти окончательный эффективный размер всех промежутков, охватываемых такими элементами; в противном случае игнорируйте влияние выравнивания дорожек при этой оценке.

2.  Далее алгоритм [определения размеров дорожек](#track-sizing-algorithm) определяет размеры [строк сетки](#grid-row).

    В этом процессе любой элемент [сетки](#grid-item), который является субгридом [контейнера сетки](#grid-container) в [оси блока](https://www.w3.org/TR/css-writing-modes-4/#block-axis), рассматривается как пустой, а его элементы сетки (внуки) рассматриваются как прямые дети контейнера сетки (их прародитель). Эта интроспекция является рекурсивной.

    Как и в случае с размерами столбцов, интроспекции подвергаются элементы, которые подсегментированы только по оси [inline axis](https://www.w3.org/TR/css-writing-modes-4/#inline-axis) и чей размер [grid-контейнера](#grid-container) по оси [block axis](https://www.w3.org/TR/css-writing-modes-4/#block-axis) зависит от размера его содержимого. (Как и в случае с размерами столбцов, вклад размера в размер строки этой сетки берется с учетом того, что размер ее дорожки был определен только до данной соответствующей точки алгоритма; и опять же, эта интроспекция является рекурсивной).

    Чтобы найти [ось строк](https://www.w3.org/TR/css-writing-modes-4/#inline-axis) [свободное пространство](https://www.w3.org/TR/css-sizing-3/#available) для элементов, чьи [ось блоков](https://www.w3.org/TR/css-writing-modes-4/#block-axis) размерные вклады требуют его, используйте размеры [столбцов сетки](#grid-column), рассчитанные на предыдущем шаге. Если [inline size](https://www.w3.org/TR/css-writing-modes-4/#inline-size) [grid-container](#grid-container) является [definite](https://www.w3.org/TR/css-sizing-3/#definite), также примените [justify-content](https://www.w3.org/TR/css-align-3/#propdef-justify-content), чтобы учесть эффективные размеры зазора между колонками.

3.  Затем, если [min-content contribution](https://www.w3.org/TR/css-sizing-3/#min-content-contribution) любого элемента сетки изменился на основе размеров строк и выравнивания, рассчитанных в шаге 2, заново определите размеры [колонок сетки](#grid-column) с новыми min-content и [max-content contributions](https://www.w3.org/TR/css-sizing-3/#max-content-contribution) (только один раз).

    Чтобы найти [ось блока](https://www.w3.org/TR/css-writing-modes-4/#block-axis) [свободное пространство](https://www.w3.org/TR/css-sizing-3/#available) для элементов, чьи [ось инлайна](https://www.w3.org/TR/css-writing-modes-4/#inline-axis) размеры требуют этого, используйте размеры [строки сетки](#grid-row), рассчитанные на предыдущем шаге. Если [размер блока](https://www.w3.org/TR/css-writing-modes-4/#block-size) [контейнера сетки](#grid-container) является [определенным](https://www.w3.org/TR/css-sizing-3/#definite), также примените [align-content](https://www.w3.org/TR/css-align-3/#propdef-align-content), чтобы учесть эффективные размеры промежутков между строками.

    Это повторение необходимо для случаев, когда [inline size](https://www.w3.org/TR/css-writing-modes-4/#inline-size) элемента [сетки](#grid-item) зависит от [block size](https://www.w3.org/TR/css-writing-modes-4/#block-size) его [grid area](#grid-area). Примерами являются обернутые колонки [flex-контейнеры](https://www.w3.org/TR/css-flexbox-1/#flex-container) ([flex-flow: column wrap](https://www.w3.org/TR/css-flexbox-1/#propdef-flex-flow)), [orthogonal flows](https://www.w3.org/TR/css-writing-modes-4/#establish-an-orthogonal-flow) ([writing-mode](https://www.w3.org/TR/css-writing-modes-4/#propdef-writing-mode)) и [multi-column containers](https://www.w3.org/TR/css-multicol-1/#multi-column-container).

4.  Далее, если [min-content contribution](https://www.w3.org/TR/css-sizing-3/#min-content-contribution) какого-либо элемента сетки изменился на основе размеров столбцов и выравнивания, рассчитанных в шаге 3, заново определите размеры строк [grid rows](#grid-row) с новыми min-content и [max-content contributions](https://www.w3.org/TR/css-sizing-3/#max-content-contribution) (только один раз).

    Чтобы найти [inline-axis](https://www.w3.org/TR/css-writing-modes-4/#inline-axis) [доступное пространство](https://www.w3.org/TR/css-sizing-3/#available) для всех элементов, чьи [block-axis](https://www.w3.org/TR/css-writing-modes-4/#block-axis) размеры требуют этого, используйте размеры [grid column](#grid-column), рассчитанные на предыдущем шаге. Если [inline size](https://www.w3.org/TR/css-writing-modes-4/#inline-size) [grid-container](#grid-container) является [definite](https://www.w3.org/TR/css-sizing-3/#definite), также примените [justify-content](https://www.w3.org/TR/css-align-3/#propdef-justify-content), чтобы учесть эффективные размеры зазора между колонками.

5.  Наконец, размер [grid-контейнера](#grid-container) определяется с использованием полученного размера [grid](#grid) в качестве размера содержимого, а дорожки выравниваются внутри grid-контейнера в соответствии со свойствами [align-content](https://www.w3.org/TR/css-align-3/#propdef-align-content) и [justify-content](https://www.w3.org/TR/css-align-3/#propdef-justify-content).

    Примечание: Это может привести к появлению дополнительного пространства между дорожками, потенциально увеличивая область сетки для любых элементов сетки, охватывающих промежутки, за пределы пространства, выделенного при изменении размера дорожек.


Примечание: При определении размера дорожек в измерении [subgridded](#subgridded-axis) каждый элемент данной дорожки по этой оси рассматривается как член [parent grid](#parent-grid). Такое чередование требует, чтобы размерность сетки уменьшалась по оси на [подсетки](#subgrid), а не заполняла обе оси при рекурсии. Обратите внимание, это означает, что для подсеток, устанавливающих [ортогональный поток](https://www.w3.org/TR/css-writing-modes-4/#establish-an-orthogonal-flow), порядок определения размеров дорожек будет инвертирован по сравнению с вложенными сетками.

После того как размер каждой [области сетки](#grid-area) определен, элементы [сетки](#grid-item) раскладываются в соответствующие содержащие их блоки. Для этого ширина и высота области сетки считаются [определенными](https://www.w3.org/TR/css-sizing-3/#definite).

Примечание: Поскольку формулы, рассчитанные с использованием только определенных размеров, такие как формула [stretch fit](https://www.w3.org/TR/css-sizing-3/#stretch-fit), также являются определенными, размер элемента сетки, который растягивается, также считается определенным.

[](#example-c45a7148)Следующий пример иллюстрирует, как определяются размеры подсеток по осям:

Предположим, у нас есть родительский контейнер сетки A, который содержит элемент B, имеющий подсеточные столбцы, и содержит внука B, имеющего подсеточные строки, и внука D, который является просто вложенной сеткой.

&lt;grid-A&gt;
&lt;grid-B subgrid=columns&gt;
&lt;grid-C subgrid=rows/&gt;
&lt;grid-D&gt;
&lt;/grid-B&gt;
&lt;grid-A&gt;

Когда A размещает свои столбцы, он рассматривает элементы B как вставленные в соответствующие столбцы A, но когда A размещает свои строки, он рассматривает B как отдельный элемент (контейнер сетки с собственными строками и некоторыми элементами, включая элементы C и D). Аналогично, когда B размещает свои строки, он рассматривает элементы C как вписанные в строки B, но когда B размещает свои столбцы, он рассматривает C как отдельный элемент, как и в случае с D. Нет никакой связи между строками C и строками A, потому что строки в B вложены, а не разбиты на подрешетки.

На высоком уровне алгоритм работы с сеткой выглядит следующим образом:

1.  Определить размер столбцов
2.  Определить размер строк
3.  Отрегулируйте столбцы (при необходимости, основываясь на окончательных размерах строк).

Таким образом, алгоритм изменения размеров сетки в этом примере будет выглядеть следующим образом:

1.  **Разрешить размеры столбцов сетки A, используя размеры элементов сетки A, рассматривая B как пустой, но рассматривая его дочерние элементы (включая C и D) как элементы сетки A.**.

    Алгоритм сетки просто выполняет рекурсию в D. Для C все сложнее:

1.  Определите размер столбцов C.
2.  Определите размер строк C, увеличив размер строк B.
3.  Скорректируйте столбцы C.
4.  Верните конечные размеры столбцов C.

Правильный размер строк B требует конечных размеров столбцов C, поскольку размер строки зависит от размера столбца, и, следовательно, строки B вполне могут зависеть от конечных размеров столбцов C. Чтобы разорвать эту циклическую зависимость, нам нужно разделить алгоритм так, чтобы он зависел от начального приближения конечных размеров столбцов C, а корректировку выполнять позже. Таким образом, для C нам нужно выполнить рекурсию только для определения размера столбцов и передать этот начальный размер A для определения размера его начальных столбцов.

Позже, когда мы будем определять размеры строк B, мы определим размеры строк C (которые являются подсеточными) и завершим определение размеров C, окончательно определив размеры его столбцов. Если это привело к изменениям, у нас есть возможность запустить проход корректировки для столбцов A во время прохода корректировки.

2.  **Далее определите размеры строк A, используя размеры элементов сетки A, рассматривая B как отдельный элемент**.

    Поскольку размер B, как подсетки, разделен на несколько проходов, алгоритм сетки выдает только рекурсию по определению размера строки в B: определяем размер строк B, рассматривая D как отдельный элемент, запрашивая его окончательный размер, а C рассматриваем как пустой элемент и поднимаем его дочерние элементы как элементы в сетку B.

    B возвращает свой окончательный размер строки, который учитывается при выполнении рекурсии A по определению размера строки.

3.  **Если окончательный размер C изменился в результате прохода через B, это должно вызвать изменение размера столбцов B, что вызовет проход изменения размера столбцов A.

### 12.2. Терминология определения размеров дорожек[](#algo-terms)

функция определения размера дорожки min

Если размер дорожки был задан с помощью функции [minmax()](#valdef-grid-template-columns-minmax), то это первый аргумент этой функции. Если размер дорожки был задан с помощью значения [&lt;flex&gt;](#typedef-flex "Expands to: fr") или функции [fit-content()](#valdef-grid-template-columns-fit-content), то [auto](#valdef-grid-template-columns-auto). Иначе - функция размера дорожки.

Функция максимального размера дорожки

Если размер дорожки был задан с помощью функции [minmax()](#valdef-grid-template-columns-minmax), то это второй аргумент этой функции. В противном случае - функция определения размера дорожки. Во всех случаях [auto](#valdef-grid-template-columns-auto) и [fit-content()](#valdef-grid-template-columns-fit-content) рассматриваются как [max-content](#valdef-grid-template-columns-max-content), кроме случаев, когда для fit-content() указано иное.

доступное пространство сетки

Независимо в каждом измерении, [доступное пространство сетки](#available-grid-space) является:

* Если размер [контейнера сетки](#grid-container) определен, то используйте размер его поля содержимого.

* Если размер [контейнера сетки](#grid-container) определяется ограничением [min-content constraint](https://www.w3.org/TR/css-sizing-3/#min-content-constraint) или [max-content constraint](https://www.w3.org/TR/css-sizing-3/#max-content-constraint), то [доступное пространство сетки](#available-grid-space) является этим ограничением (и является неопределенным).


Примечание: размеры [auto](#grid-placement-auto), указывающие на размер, основанный на содержимом (например, высота блока-уровня в горизонтальном режиме письма), эквивалентны [max-content](#valdef-grid-template-columns-max-content).

Во всех случаях зажимайте [доступное пространство сетки](#available-grid-space) в соответствии со свойствами [контейнера сетки](#grid-container) min/max-width/height, если они определены.

свободное пространство

Равно [доступному пространству сетки](#available-grid-space) минус сумма [базовых размеров](#base-size) всех дорожек сетки (включая желоба), равная нулю. Если доступное пространство сетки [неограниченно](https://www.w3.org/TR/css-sizing-3/#indefinite), то [свободное пространство](#free-space) также неограниченно.

span count[](#span-count)

Количество дорожек [сетки](#grid-track), пересеченных элементом [сетки](#grid-item) в применимом измерении.

Примечание: Помните, что [желоба](#gutters) рассматриваются как дорожки фиксированного размера - дорожки с их функциями min и max размера, установленными на используемый размер желоба - для целей алгоритма определения размера сетки. Их ширина должна быть включена в расчеты [алгоритма определения размера дорожек](#track-sizing-algorithm) соответствующим образом.

### 12.3. Алгоритм определения размера дорожки[](#algo-track-sizing)

Оставшаяся часть этого раздела представляет собой алгоритм определения размера дорожки, который вычисляет из функций [min](#min-track-sizing-function) и [max track sizing function](#max-track-sizing-function) используемый размер дорожки. Каждая дорожка имеет базовый размер, [&lt;length&gt;](https://www.w3. org/TR/css-values-3/#length-value "Expands to: advance measure | cap | ch | cm | em | ex | ic | in | lh | mm | pc | pt | px | q | rem | rlh | vb | vh | vi | vmax | vmin | vw"), который растет в течение всего алгоритма и в конечном итоге будет окончательным размером дорожки, и предел роста, &lt;length&gt;, который обеспечивает желаемый максимальный размер для [базового размера](#base-size). В алгоритме 5 шагов:

1.  [Инициализация размеров дорожек](#algo-init)
2.  [Решить внутренние размеры дорожек](#algo-content)
3.  [Maximize Tracks](#algo-grow-tracks)
4.  [Расширить гибкие дорожки](#algo-flex-tracks)
5.  \[\[#algo-stretch|Expand Stretched auto Tracks\]\]

### 12.4. Инициализация размеров дорожек[](#algo-init)

**Инициализируйте базовый размер и предел роста каждой дорожки.** Для каждой дорожки, если [функция минимального размера дорожки](#min-track-sizing-function) является:

A [функция фиксированного размера](#fixed-sizing-function)

Приведите к абсолютной длине и используйте этот размер в качестве начального [базового размера](#base-size) дорожки.

Примечание: [Неопределенные](https://www.w3.org/TR/css-sizing-3/#indefinite) длины не могут иметь место, так как они рассматриваются как [auto](#valdef-grid-template-columns-auto).

Функция [внутреннего размера](#intrinsic-sizing-function)

Используйте начальный [базовый размер](#base-size), равный нулю.

Для каждой дорожки, если [функция максимального размера дорожки](#max-track-sizing-function) является:

A [функция фиксированного размера](#fixed-sizing-function).

Приведите к абсолютной длине и используйте этот размер в качестве начального [предела роста](#growth-limit) дорожки.

[внутренняя функция определения размера](#intrinsic-sizing-function)

[гибкая функция определения размера](#flexible-sizing-function)

Использовать начальный [предел роста](#growth-limit), равный бесконечности.

Во всех случаях, если [предел роста](#growth-limit) меньше, чем [базовый размер](#base-size), увеличьте предел роста до соответствия базовому размеру.

Примечание: [Желоба](https://www.w3.org/TR/css-align-3/#gutter) рассматриваются как пустые дорожки фиксированного размера для целей алгоритма [определения размера дорожки](#track-sizing-algorithm).

### 12.5. Разрешение присущих размеров дорожек[](#algo-content)

На этом шаге выполняется преобразование присущих дорожкам [функций определения размеров](#grid-template-rows-track-sizing-function) в абсолютные длины. Сначала он определяет размеры на основе элементов, которые полностью содержатся в одной дорожке. Затем она постепенно добавляет требования к пространству для элементов, которые охватывают несколько дорожек, равномерно распределяя дополнительное пространство по этим дорожкам, насколько это возможно.

Примечание: После завершения этого шага все присущие [базовые размеры](#base-size) и [пределы роста](#growth-limit) будут приведены к абсолютной длине.

Примечание: [Помните, что](#algo-terms) [fit-content()](#valdef-grid-template-columns-fit-content) и [auto](#grid-placement-auto) [max track sizing functions](#max-track-sizing-function) рассматриваются так же, как [max-content](#valdef-grid-template-columns-max-content), за исключением случаев, когда явно указано иное.

1.  [](#algo-baseline-shims)** Выровняйте элементы, выровненные по базовой линии, чтобы их вклад в размер отражал их базовое выравнивание.** Для элементов в каждой [группе разделения базовой линии](https://www.w3.org/TR/css-align-3/#baseline-sharing-group) добавьте "шим" (фактически, дополнительное поле) на начальной/конечной стороне (для первого/последнего выравнивания по базовой линии) каждого элемента, чтобы при выравнивании по началу/концу их [базовые линии выравнивались, как указано](https://www.w3.org/TR/css-align-3/#baseline-values).

    Рассматривайте эти "прокладки" как часть вклада элементов в собственный размер для целей определения размеров дорожек, о которых речь пойдет ниже. Если элемент использует несколько собственных вкладов в размер, для каждого из них могут быть свои "шимы".

    [](#example-497433d9)Например, когда [grid-контейнер](#grid-container) имеет [неопределенный](https://www.w3.org/TR/css-sizing-3/#indefinite) размер, он сначала выкладывается под ограничениями min/max-содержания, чтобы найти размер, а затем выкладывается "по-настоящему" с этим размером (что может повлиять на такие вещи, как процентные треки). Шиммы, добавляемые для каждой фазы, независимы и влияют на раскладку только во время этой фазы.

    Примечание: Обратите внимание, что на этом этапе учитываются элементы [baseline self-aligned](https://www.w3.org/TR/css-align-3/#baseline-align-self) и [baseline content-aligned](https://www.w3.org/TR/css-align-3/#baseline-align-content).

    Примечание: Поскольку элементы [сетки](#grid-item), чей собственный размер зависит от размера дорожки собственного размера, [не участвуют в выравнивании по базовой линии](#row-align), они не шиммируются.

2.  [](#algo-single-span-items)**Размер дорожек для размещения нешироких элементов:** Для каждой дорожки с присущей [функцией размера дорожки](#grid-template-rows-track-sizing-function), а не [гибкой функцией размера](#flexible-sizing-function), учитывайте элементы в ней с диапазоном 1:

    Для минимумов min-содержания:

    Если дорожка имеет [min-content](#valdef-grid-template-columns-min-content) [min track sizing function](#min-track-sizing-function), установите ее [base size](#base-size) на максимальный из [min-content contributions](https://www.w3.org/TR/css-sizing-3/#min-content-contribution) элементов, равный нулю.

    Для минимумов max-содержания:

    Если у дорожки есть [max-content](#valdef-grid-template-columns-max-content) [min track sizing function](#min-track-sizing-function), установите ее [base size](#base-size) на максимальный из [max-content contributions](https://www.w3.org/TR/css-sizing-3/#max-content-contribution) элементов, равный нулю.

    Для автоминимумов:

    Если дорожка имеет [auto](#valdef-grid-template-columns-auto) [min track sizing function](#min-track-sizing-function) и размер [grid-контейнера](#grid-container) определяется ограничением [min-](https://www.w3.org/TR/css-sizing-3/#min-content-constraint)/[max-content constraint](https://www.w3.org/TR/css-sizing-3/#max-content-constraint), установите [base size](#base-size) дорожки на максимальный из [limited min-/max-content contributions](#limited-contribution) элементов (соответственно), равный нулю. Ограниченный минимальный/максимальный вклад элемента - это (для данной цели) его [минимальный](https://www.w3.org/TR/css-sizing-3/#min-content-contribution)/[максимальный вклад](https://www.w3. org/TR/css-sizing-3/#max-content-contribution) (соответственно), ограниченный функцией [max track sizing function](#max-track-sizing-function) (которая может быть аргументом функции [fit-content()](#valdef-grid-template-columns-fit-content)), если она [fixed](#fixed-sizing-function), и в конечном итоге ограниченный его [minimum contribution](#minimum-contribution) (определено ниже).

    В противном случае установите [базовый размер](#base-size) дорожки на максимальный из [минимальных вкладов](#minimum-contribution) ее элементов, равный нулю. Минимальный вклад элемента - это наименьший [внешний размер](https://www.w3.org/TR/css-sizing-3/#outer-size), который он может иметь. В частности, если вычисленный [предпочтительный размер](https://www.w3.org/TR/css-sizing-3/#preferred-size) элемента [ведет себя как auto](https://www.w3.org/TR/css-sizing-3/#behave-as-auto) или зависит от размера его [содержащего блока](https://www.w3.org/TR/css-display-3/#containing-block) на соответствующей оси, то его минимальный вклад - это внешний размер, который получится, если принять используемый [минимальный размер](https://www.w3.org/TR/css-sizing-3/#min-width) элемента за его предпочтительный размер; в противном случае минимальный вклад элемента - это его [минимальный вклад в содержание](https://www.w3.org/TR/css-sizing-3/#min-content-contribution). Поскольку минимальный вклад часто зависит от размера содержимого элемента, он считается разновидностью [вклада внутреннего размера](https://www.w3.org/TR/css-sizing-3/#intrinsic-size-contribution).

    Примечание: Для элементов с заданным минимальным размером [auto](https://www.w3.org/TR/css-sizing-3/#valdef-width-auto) (начальное значение), [минимальный вклад](#minimum-contribution) обычно эквивалентен [min-content contribution](https://www.w3.org/TR/css-sizing-3/#min-content-contribution)- но в некоторых случаях может отличаться, см. Кроме того, минимальный вклад ≤ минимальный вклад в контент ≤ [максимальный вклад в контент](https://www.w3.org/TR/css-sizing-3/#max-content-contribution).

    Для максимальных значений min-content:

    Если у трека есть [min-content](#valdef-grid-template-columns-min-content) [max track sizing function](#max-track-sizing-function), установите его [growth limit](#growth-limit) на максимальный из [min-content contributions](https://www.w3.org/TR/css-sizing-3/#min-content-contribution) элементов.

    Для максимумов max-содержания:

    Если у дорожки есть [max-content](#valdef-grid-template-columns-max-content) [max track sizing function](#max-track-sizing-function), установите ее [growth limit](#growth-limit) на максимальный вклад элементов [max-content contributions](https://www.w3.org/TR/css-sizing-3/#max-content-contribution). Для максимумов [fit-content()](#valdef-grid-template-columns-fit-content) дополнительно зажмите этот предел роста аргументом fit-content().

    Во всех случаях, если [предел роста](#growth-limit) дорожки теперь меньше, чем ее [базовый размер](#base-size), увеличьте предел роста до соответствия базовому размеру.

    Примечание: Этот шаг является упрощением описанных ниже шагов по работе с элементами, имеющими размах, и должен давать такое же поведение, как и выполнение этих инструкций для элементов с размахом 1.

3.  [](#algo-spanning-items)**Увеличение размеров для учета пролетающих элементов, пересекающих дорожки с размером содержимого:** Далее рассмотрим элементы с пролетом 2, которые не пересекают дорожку с [гибкой функцией определения размера](#flexible-sizing-function).

1.  [](#track-size-intrinsic-min)**Для присущих минимумов:** Сначала увеличьте [базовый размер](#base-size) дорожек с [присущей](#intrinsic-sizing-function) [функцией минимального размера дорожки](#min-track-sizing-function), [распределив дополнительное пространство](#extra-space), необходимое для размещения [минимального вклада](#minimum-contribution) этих элементов.

    Если размер контейнера сетки задан с учетом [min-](https://www.w3.org/TR/css-sizing-3/#min-content-constraint) или [max-content constraint](https://www.w3.org/TR/css-sizing-3/#max-content-constraint), используйте здесь [ограниченный min-content contributions](#limited-contribution) вместо их [minimum contributions](#minimum-contribution). (Для элемента, охватывающего несколько дорожек, верхний предел, используемый для вычисления его ограниченного вклада в мин/макс-контент, равен _сумме_ [фиксированных](#fixed-sizing-function) [max track sizing functions](#max-track-sizing-function) всех дорожек, которые он охватывает, и применяется, если он охватывает только такие дорожки).

2.  [](#track-size-content-min)**Для контентных минимумов: ** Далее продолжайте увеличивать [базовый размер](#base-size) дорожек с [минимальной функцией размера дорожки](#min-track-sizing-function) [min-content](#valdef-grid-template-columns-min-content) или [max-content](#valdef-grid-template-columns-max-content), [распределяя дополнительное пространство](#extra-space) по мере необходимости для учета вклада этих элементов [min-content](https://www. w3.org/TR/css-sizing-3/#min-content-contribution).
3.  [](#track-size-max-content-min)**Для минимумов максимального содержимого:** Далее, если размер контейнера сетки определяется ограничением [max-content](https://www.w3. org/TR/css-sizing-3/#max-content-constraint), продолжайте увеличивать [базовый размер](#base-size) дорожек с [функцией минимального размера дорожки](#min-track-sizing-function) [auto](#valdef-grid-template-columns-auto) или [max-content](#valdef-grid-template-columns-max-content), [распределяя дополнительное пространство](#extra-space) по мере необходимости, чтобы учесть [ограниченный вклад максимального содержания](#limited-contribution) этих элементов.

    Во всех случаях продолжайте увеличивать [базовый размер](#base-size) дорожек с [минимальной функцией размера дорожки](#min-track-sizing-function) от [max-content](#valdef-grid-template-columns-max-content) путем [распределения дополнительного пространства](#extra-space) по мере необходимости для учета [max-content contributions](https://www.w3.org/TR/css-sizing-3/#max-content-contribution) этих элементов.

4.  Если на данный момент [предел роста](#growth-limit) какого-либо трека меньше, чем его [базовый размер](#base-size), увеличьте его предел роста до соответствия базовому размеру.
5.  **Для присущих максимумов:** Далее увеличьте [предел роста](#growth-limit) дорожек с [присущей](#intrinsic-sizing-function) [функцией максимального размера дорожки](#max-track-sizing-function), [распределив дополнительное пространство](#extra-space), необходимое для учета [вклада min-содержания](https://www.w3.org/TR/css-sizing-3/#min-content-contribution) этих элементов. Пометьте все дорожки, чей предел роста изменился с бесконечного на конечный на этом шаге, как бесконечно растущие для следующего шага. Зачем существует флаг [infinitely growable](#infinitely-growable)?

    [Питер Салас объясняет](https://lists.w3.org/Archives/Public/www-style/2014Mar/0500.html):

    > Рассмотрим следующий случай:
    >
    > Два "автоматических" трека (т. е. minmax(min-content, max-content) minmax(min-content, max-content)).
    > Элемент 1 находится на дорожке 1 и имеет min-content = max-content = 10.
    > Элемент 2 охватывает дорожки 1 и 2 и имеет min-content = 30, max-content = 100.
    >
    > После определения min-content/max-content для первого элемента мы имеем следующее.
    >
    > дорожка 1: базовый размер = 10 предел роста = 10
    >
    > дорожка 2: базовый размер = 0 предел роста = бесконечность
    >
    > Затем мы определяем min-content/max-content для второго элемента.
    >
    > Фаза 1 устанавливает базовый размер дорожки 2 равным 20, так что базовые размеры двух дорожек в сумме составляют 30.
    > Фаза 2 ничего не делает, потому что нет соответствующих дорожек.
    > Фаза 3 устанавливает предел роста дорожки 2 равным 20, так что пределы роста двух дорожек равны 30.
    > В фазе 4 нам нужно увеличить сумму пределов роста на 70, чтобы учесть элемент 2.
    > Возможны два варианта:
    >
    > 1\. Увеличить пределы роста каждой дорожки поровну,
    > и в итоге получить пределы роста = \[45, 55\].
    > 2\. Увеличиваем предел роста только второй дорожки,
    > и в итоге пределы роста = \[10, 90\].
    >
    > Не рассматривая только что установленный предел роста как ограничение при распределении пространства
    > (т.е. рассматривая его как бесконечность),
    > мы получаем второй результат,
    > который мы считаем лучшим результатом, поскольку размер первой дорожки остается точно таким же, как у первого элемента.
6.  **Для максимального содержания:** Наконец, продолжайте увеличивать [предел роста](#growth-limit) дорожек с [максимальной функцией размера дорожки](#max-track-sizing-function) от [max-content](#valdef-grid-template-columns-max-content), [распределяя дополнительное пространство](#extra-space), необходимое для учета [max-content contributions](https://www.w3.org/TR/css-sizing-3/#max-content-contribution) этих элементов. Однако ограничьте рост любых дорожек [fit-content()](#valdef-grid-template-columns-fit-content) их аргументом fit-content().

Повторяйте шаг за шагом для элементов с большим диапазоном, пока не будут рассмотрены все элементы.

4.  [](#algo-spanning-flex-items)**Увеличение размеров для размещения элементов, пересекающих [гибкие дорожки](#flexible-tracks):** Далее повторите предыдущий шаг, рассматривая (вместе, а не группируя по размеру пролета) все элементы, которые _до_ пересекают дорожку с [гибкой функцией определения размеров](#flexible-sizing-function), при этом
* распределяя пространство _только_ на [гибкие дорожки](#flexible-tracks) (т. е. рассматривая все остальные дорожки как имеющие [фиксированную функцию размера](#fixed-sizing-function))
* если сумма [функций гибкого размера](#flexible-sizing-function) всех [гибких путей](#flexible-tracks), охватываемых элементом, больше нуля, распределять пространство между такими путями в соответствии с соотношениями их функций гибкого размера, а не распределять пространство поровну.
5.  [](#algo-finite-growth)Если какая-либо дорожка все еще имеет бесконечный [предел роста](#growth-limit) (например, потому что на нее не было помещено ни одного предмета или она является [гибкой дорожкой](#flexible-tracks)), установите ее предел роста на ее [базовый размер](#base-size).

Примечание: Не существует единого способа удовлетворить внутренние ограничения по размеру, когда предметы располагаются на нескольких дорожках. Этот алгоритм воплощает в себе ряд эвристик, которые показали хорошие результаты в реальных примерах использования, таких как примеры "игры"̣, приведенные ранее в этой спецификации. В будущем этот алгоритм может быть обновлен, чтобы учесть более совершенные эвристики по мере их выявления.

#### 12.5.1. Распределение дополнительного пространства по пространственным дорожкам[](#extra-space)

Распределение дополнительного пространства[](#distribute-extra-space) путем увеличения затронутых размеров набора дорожек в соответствии с требованиями набора вкладов в размер,

1.  Ведите отдельно для каждого затронутого [базового размера](#base-size) или [предела роста](#growth-limit) запланированное увеличение, первоначально установленное на 0. (Это предотвращает зависимость увеличения размера от порядка).
2.  Для каждого рассматриваемого элемента,
1.  **Найдите место для распределения:** Вычтите соответствующий размер ([базовый размер](#base-size) или [предел роста](#growth-limit)) _каждой_ охваченной дорожки из вклада элемента в размер, чтобы найти оставшийся вклад элемента в размер. (Для бесконечных пределов роста подставьте базовый размер дорожки.) Это пространство, которое нужно распределить. Установите нулевое значение.

    extra-space = max(0, size-contribution \- ∑track-sizes)

2.  **Распределите пространство до пределов:** Найдите прирост, вызванный предметом, для каждого охваченного пути с затронутым размером, распределив пространство поровну между такими путями, заморозив прирост, вызванный предметом, когда его затронутый размер + прирост, вызванный предметом, достигнут предела (и продолжая увеличивать размороженные пути по мере необходимости).

    Для [базовых размеров](#base-size) пределом является его [предел роста](#growth-limit). Для пределов роста предел равен бесконечности, если он отмечен как [бесконечно растущий](#infinitely-growable), и равен пределу роста в противном случае.

    Примечание: Если затронутый размер был [пределом роста](#growth-limit), а трек не помечен как [infinitely growable](#infinitely-growable), то каждое увеличение, вызванное элементом, будет равно нулю.

3.  **Распределение пространства за пределами ограничений:** Если после замораживания всех дорожек осталось пространство, разморозьте их и продолжайте распределять пространство в соответствии с приростом, вызванным...

* при [размещении минимальных вкладов](#track-size-intrinsic-min) или [размещении минимальных вкладов в контент](#track-size-content-min): любой затронутый трек, у которого также есть присущая [max track sizing function](#max-track-sizing-function); если таких треков нет, то все затронутые треки.
* при [учете вклада max-content](#track-size-max-content-min): любая затронутая дорожка, которая случайно также имеет [max-content](#valdef-grid-template-columns-max-content) [max track sizing function](#max-track-sizing-function); если таких дорожек нет, то все затронутые дорожки.
* при обработке любого присущего [ограничения роста](#growth-limit): все затронутые дорожки.

  Для этого [максимальная функция размера дорожки](#max-track-sizing-function) дорожки [fit-content()](#valdef-grid-template-columns-fit-content) рассматривается как [max-content](#valdef-grid-template-columns-max-content) до достижения предела, указанного в качестве аргумента fit-content(), после чего она рассматривается как имеющая [фиксированную функцию размера](#fixed-sizing-function) этого аргумента.

  Примечание: На этом шаге приоритет распределения пространства для размещения пространства, необходимого дорожкам [min track sizing functions](#min-track-sizing-function) за пределами их текущих пределов роста, определяется типами их [max track sizing functions](#max-track-sizing-function).

4.  Для каждого затронутого трека, если произошедшее увеличение элемента трека больше, чем запланированное увеличение трека, установите запланированное увеличение трека на это значение.
3.  **Обновите затронутые размеры дорожек**, добавив запланированное увеличение, чтобы следующий раунд распределения пространства учитывал это увеличение. (Если затронутый размер является бесконечным [пределом роста](#growth-limit), установите его на [базовый размер](#base-size) дорожки плюс запланированное увеличение).

### 12.6. Максимизировать дорожки[](#algo-grow-tracks)

Если [свободное пространство](#free-space) положительно, распределите его поровну между [базовыми размерами](#base-size) всех дорожек, замораживая дорожки по мере достижения ими [пределов роста](#growth-limit) (и продолжая выращивать незамороженные дорожки по мере необходимости).

Для целей этого шага: если размер [контейнера сетки](#grid-container) определяется ограничением [max-content](https://www.w3.org/TR/css-sizing-3/#max-content-constraint), то [свободное пространство](#free-space) будет бесконечным; если размер определяется ограничением [min-content](https://www.w3.org/TR/css-sizing-3/#min-content-constraint), то свободное пространство будет равно нулю.

Если в результате сетка окажется больше, чем [внутренний размер](#grid-container)(https://www.w3.org/TR/css-sizing-3/#inner-size), ограниченный [max-width/height](https://www.w3.org/TR/CSS2/visudet.html#propdef-max-width), то выполните этот шаг заново, считая [доступное пространство сетки](#available-grid-space) равным внутреннему размеру контейнера сетки при его максимальных ширине/высоте.

### 12.7. Расширить гибкие дорожки[](#algo-flex-tracks)

На этом шаге выполняется расширение [гибких дорожек](#flexible-tracks) с использованием наибольшего значения, которое может быть присвоено [fr](#valdef-flex-fr) без превышения [доступного пространства](https://www.w3.org/TR/css-sizing-3/#available).

Сначала найдите используемую [flex fraction](#flex-fraction) сетки:

Если [свободное пространство](#free-space) равно нулю или если размер [контейнера сетки](#grid-container) ограничен [min-content constraint](https://www.w3.org/TR/css-sizing-3/#min-content-constraint):

Используемая [flex fraction](#flex-fraction) равна нулю.

В противном случае, если [свободное пространство](#free-space) имеет [определенную](https://www.w3.org/TR/css-sizing-3/#definite) длину:

[flex fraction](#flex-fraction) является результатом [нахождения размера fr](#algo-find-fr-size) с использованием всех [треков сетки](#grid-track) и [пространства для заполнения](#space-to-fill) из [доступного пространства сетки](#available-grid-space).

Иначе, если [свободное пространство](#free-space) имеет [неопределенную](https://www.w3.org/TR/css-sizing-3/#indefinite) длину:

Используемая [flex fraction](#flex-fraction) является максимальной из:

* Для каждой гибкой дорожки, если [коэффициент гибкости](#grid-template-columns-flex-factor) больше единицы, результат деления [базового размера](#base-size) дорожки на коэффициент гибкости; в противном случае - базовый размер дорожки.
* Для каждого [элемента сетки](#grid-item), который пересекает гибкую дорожку, результат [нахождения размера fr](#algo-find-fr-size) с использованием всех дорожек сетки, которые пересекает элемент, и [пространства для заполнения](#space-to-fill) от [max-content contribution](https://www.w3.org/TR/css-sizing-3/#max-content-contribution) элемента.

Если использование этой [flex fraction](#flex-fraction) приведет к тому, что [grid](#grid) будет меньше, чем [min-width/height](https://www.w3.org/TR/CSS2/visudet.html#propdef-min-width) контейнера [grid-container] (или больше, чем [max-width/height](https://www.w3.org/TR/CSS2/visudet. html#propdef-max-width)), то повторите этот шаг, рассматривая [свободное пространство](#free-space) как определенное, а [доступное пространство сетки](#available-grid-space) как равное [внутреннему размеру](https://www.w3.org/TR/css-sizing-3/#inner-size) контейнера сетки, когда его размеры соответствуют его минимальной ширине/высоте (максимальной ширине/высоте).

Для каждой [гибкой дорожки](#flexible-tracks), если произведение используемой [flex fraction](#flex-fraction) и [flex factor](#grid-template-columns-flex-factor) дорожки больше, чем [base size](#base-size), установите ее базовый размер на это произведение.

#### 12.7.1. Поиск размера [fr](#valdef-flex-fr)[](#algo-find-fr-size)

Этот алгоритм находит наибольший размер, который может иметь блок [fr](#valdef-flex-fr), не превышая целевого размера. Он должен быть вызван с набором [треков сетки](#grid-track) и некоторым количеством пространства для заполнения.

1.  Пусть оставшееся пространство - это [пространство для заполнения](#space-to-fill) минус [базовые размеры](#base-size) негибких [дорожек сетки](#grid-track).
2.  Пусть flex factor sum - это сумма [flex factors](#grid-template-columns-flex-factor) [гибких дорожек](#flexible-tracks). Если это значение меньше 1, установите вместо него 1.
3.  Пусть гипотетический размер fr будет равен [остаточному пространству](#leftover-space), деленному на сумму [flex factor sum](#flex-factor-sum).
4.  Если произведение [гипотетического размера fr](#hypothetical-fr-size) и [гибкой дорожки](#flexible-tracks) [flex factor](#grid-template-columns-flex-factor) меньше базового размера дорожки, перезапустите этот алгоритм, считая все такие дорожки негибкими.
5.  Верните [гипотетический размер фр](#hypothetical-fr-size).

### 12.8. Растянуть автотреки[](#algo-stretch)

Этот шаг расширяет дорожки, которые имеют [auto](#valdef-grid-template-columns-auto) [max track sizing function](#max-track-sizing-function) путем деления любого оставшегося положительного, [definite](https://www.w3.org/TR/css-sizing-3/#definite) [свободного пространства](#free-space) поровну между ними. Если свободное пространство [неопределенное](https://www.w3.org/TR/css-sizing-3/#indefinite), но у [контейнера сетки](#grid-container) есть определенный [min-width/height](https://www.w3.org/TR/CSS2/visudet.html#propdef-min-width), используйте этот размер для расчета свободного пространства для этого шага.
