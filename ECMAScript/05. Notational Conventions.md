5 Условные обозначения
========================

5.1 Синтаксические и лексические грамматики
==================================

5.1.1 Контекстно-свободные грамматики
===========================

Бесконтекстная грамматика_ состоит из множества _произведений_. Каждая продукция имеет абстрактный символ, называемый _нетерминалом_, в качестве своей _левой стороны_, и последовательность из нуля или более символов нетерминала и _терминала_ в качестве своей _правой стороны_. Для каждой грамматики терминальные символы берутся из определенного алфавита.

Цепная продукция - это продукция, которая имеет ровно один нетерминальный символ в правой части и ноль или более терминальных символов.

Начиная с предложения, состоящего из одного выделенного нетерминала, называемого символом цели, данная контекстно-свободная грамматика задает _язык_, а именно (возможно, бесконечное) множество возможных последовательностей терминальных символов, которые могут получиться в результате многократной замены любого нетерминала в последовательности на правую часть продукции, для которой этот нетерминал является левой частью.

5.1.2 Лексическая и RegExp-грамматика
=====================================

Лексическая грамматика_ для ECMAScript приведена в статье [12](ecmascript-language-lexical-grammar.html#sec-ecmascript-language-lexical-grammar). Эта грамматика имеет в качестве терминальных символов кодовые точки Unicode, которые соответствуют правилам для [SourceCharacter](ecmascript-language-source-code.html#prod-SourceCharacter), определенным в [11.1](ecmascript-language-source-code.html#sec-source-text). Он определяет набор продукций, начиная с [символа цели](notational-conventions.html#sec-context-free-grammars) [InputElementDiv](ecmascript-language-lexical-grammar.html#prod-InputElementDiv), [InputElementTemplateTail](ecmascript-language-lexical-grammar.html#prod-InputElementTemplateTail), [InputElementRegExp](ecmascript-language-lexical-grammar. html#prod-InputElementRegExp), [InputElementRegExpOrTemplateTail](ecmascript-language-lexical-grammar.html#prod-InputElementRegExpOrTemplateTail), или [InputElementHashbangOrRegExp](ecmascript-language-lexical-grammar. html#prod-InputElementHashbangOrRegExp), которые описывают, как последовательности таких точек кода переводятся в последовательность элементов ввода.

Элементы ввода, кроме пробелов и комментариев, образуют терминальные символы синтаксической грамматики ECMAScript и называются _токенами_ ECMAScript. Этими токенами являются [зарезервированные слова] (ecmascript-language-lexical-grammar.html#sec-keywords-and-reserved-words), идентификаторы, литералы и пунктуаторы языка ECMAScript. Кроме того, терминаторы строк, хотя и не считаются лексемами, также становятся частью потока элементов ввода и направляют процесс автоматической вставки точки с запятой ([12.10](ecmascript-language-lexical-grammar.html#sec-automatic-semicolon-insertion)). Простые пробелы и однострочные комментарии отбрасываются и не появляются в потоке входных элементов для синтаксической грамматики. Комментарий [MultiLineComment](ecmascript-language-lexical-grammar.html#prod-MultiLineComment) (то есть комментарий вида `/*`...`*/`, независимо от того, занимает ли он более одной строки) также просто отбрасывается, если он не содержит терминатора строки; но если [MultiLineComment](ecmascript-language-lexical-grammar. html#prod-MultiLineComment) содержит один или несколько терминаторов строки, то он заменяется одним терминатором строки, который становится частью потока входных элементов для синтаксической грамматики.

Грамматика _RegExp_ для ECMAScript приведена в [22.2.1](text-processing.html#sec-patterns). Эта грамматика также имеет в качестве терминальных символов кодовые точки, определенные в [SourceCharacter](ecmascript-language-source-code.html#prod-SourceCharacter). Она определяет набор продукций, начиная с [target symbol](notational-conventions.html#sec-context-free-grammars) [Pattern](text-processing.html#prod-Pattern), которые описывают, как последовательности кодовых точек переводятся в шаблоны регулярных выражений.

Произведения лексической и RegExp-грамматики отличаются наличием двух двоеточий "**::**" в качестве разделительной пунктуации. Лексическая грамматика и грамматика RegExp имеют некоторые общие функции.

5.1.3 Грамматика числовых строк
================================

В [7.1.4.1](abstract-operations.html#sec-tonumber-applied-to-the-string-type) приведена _числовая строковая грамматика_. Она имеет в качестве терминальных символов [SourceCharacter](ecmascript-language-source-code.html#prod-SourceCharacter), и используется для перевода строк в числовые значения, начиная с символа [goal](notational-conventions. html#sec-context-free-grammars) [StringNumericLiteral](abstract-operations.html#prod-StringNumericLiteral) (которая похожа, но отличается от [лексической грамматики для числовых литералов](ecmascript-language-lexical-grammar.html#sec-literals-numeric-literals)).

Произведения грамматики числовых строк отличаются наличием трех двоеточий "**:::**" в качестве пунктуации и никогда не используются для разбора исходного текста.

5.1.4 Синтаксическая грамматика
===========================

Синтаксическая грамматика_ для ECMAScript приведена в пунктах [13](ecmascript-language-expressions.html#sec-ecmascript-language-expressions) - [16](ecmascript-language-scripts-and-modules.html#sec-ecmascript-language-scripts-and-modules). В качестве терминальных символов в этой грамматике используются токены ECMAScript, определенные лексической грамматикой ([5.1.2](notational-conventions.html#sec-lexical-and-regexp-grammars)). Она определяет набор производств, начиная с двух альтернативных [символов цели](notational-conventions.html#sec-context-free-grammars) [Script](ecmascript-language-scripts-and-modules.html#prod-Script) и [Module](ecmascript-language-scripts-and-modules.html#prod-Module), которые описывают, как последовательности лексем формируют синтаксически правильные независимые компоненты программ ECMAScript.

Когда поток точек кода должен быть разобран как ECMAScript [Script](ecmascript-language-scripts-and-modules.html#prod-Script) или [Module](ecmascript-language-scripts-and-modules.html#prod-Module), он сначала преобразуется в поток входных элементов путем многократного применения лексической грамматики; этот поток входных элементов затем разбирается путем однократного применения синтаксической грамматики. Входной поток синтаксически ошибочен, если лексемы в потоке входных элементов не могут быть разобраны как один экземпляр целевого нетерминала ([Script](ecmascript-language-scripts-and-modules.html#prod-Script) или [Module](ecmascript-language-scripts-and-modules.html#prod-Module)), без остатка лексем.

При успешном разборе строится _дерево разбора_ - древовидная структура с корнями, в которой каждый узел является узлом разбора. Каждый узел разбора - это _экземпляр_ символа в грамматике; он представляет собой участок исходного текста, который может быть получен из этого символа. Корневой узел дерева разбора, представляющий весь исходный текст, является экземпляром [символа цели] разбора (notational-conventions.html#sec-context-free-grammars). Когда узел разбора является экземпляром нетерминала, он также является экземпляром некоторой продукции, которая имеет этот нетерминал в качестве левой стороны. Кроме того, у него есть ноль или более _дочерних_, по одному для каждого символа в правой части продукции: каждый дочерний узел - это узел разбора, который является экземпляром соответствующего символа.

Новые узлы разбора создаются при каждом вызове синтаксического анализатора и никогда не используются повторно при разборе даже идентичного исходного текста. Узлы разбора считаются одним и тем же узлом разбора тогда и только тогда, когда они представляют один и тот же участок исходного текста, являются экземплярами одного и того же символа грамматики и получены в результате одного и того же вызова синтаксического анализатора.

Примечание 1

Разбор одной и той же строки несколько раз приведет к появлению разных узлов разбора. Например:

    let str = "1 + 1;";
    eval(str);
    eval(str);

Каждый вызов `eval` преобразует значение `str` в [исходный текст ECMAScript](ecmascript-language-source-code.html#sec-source-text) и выполняет независимый разбор, который создает свое отдельное дерево узлов разбора. Деревья отличаются друг от друга, несмотря на то что каждый разбор оперирует исходным текстом, который был получен из одного и того же значения String.

Примечание 2

Узлы разбора являются артефактами спецификации, и от реализаций не требуется использовать аналогичную структуру данных.

Произведения синтаксической грамматики отличаются наличием только одного двоеточия "**:**" в качестве пунктуации.

Синтаксическая грамматика, представленная в пунктах [13](ecmascript-language-expressions.html#sec-ecmascript-language-expressions) - [16](ecmascript-language-scripts-and-modules. html#sec-ecmascript-language-scripts-and-modules) не является полным описанием того, какие последовательности лексем принимаются в качестве правильного ECMAScript [Script](ecmascript-language-scripts-and-modules.html#prod-Script) или [Module](ecmascript-language-scripts-and-modules.html#prod-Module). Также принимаются некоторые дополнительные последовательности лексем, а именно те, которые были бы описаны грамматикой, если бы в определенных местах (например, перед символами завершения строки) в последовательность добавлялись только точки с запятой. Кроме того, некоторые последовательности лексем, описанные грамматикой, не считаются приемлемыми, если символ окончания строки появляется в некоторых "неудобных" местах.

В некоторых случаях, чтобы избежать двусмысленности, синтаксическая грамматика использует обобщенные конструкции, которые позволяют использовать последовательности лексем, не образующие действительный ECMAScript [Script](ecmascript-language-scripts-and-modules.html#prod-Script) или [Module](ecmascript-language-scripts-and-modules.html#prod-Module). Например, эта техника используется для объектных литералов и шаблонов деструктуризации объектов. В таких случаях предоставляется более строгая _дополнительная грамматика_, которая дополнительно ограничивает допустимые последовательности лексем. Как правило, правило [ранней ошибки](error-handling-and-language-extensions.html#early-error) гласит, что в определенных контекстах "P должен покрывать N", где P - узел разбора (экземпляр обобщенной продукции), а N - нетерминал из дополнительной грамматики. Это означает:

1.  Последовательность лексем, первоначально сопоставленных P, разбирается снова, используя N в качестве [символа цели] (notational-conventions.html#sec-context-free-grammars). Если N принимает грамматические параметры, то они устанавливаются в те же значения, которые использовались при первоначальном разборе P.
2.  Если последовательность лексем может быть разобрана как один экземпляр N, без остатка, то:
    1.  Мы называем этот экземпляр N (узел разбора, уникальный для данного P) "тем N, который охватывается P".
    2.  Все правила ранних ошибок для N и его производных также применяются к N, который покрывается P.
3.  В противном случае (если разбор не удался), это ранняя синтаксическая ошибка.

5.1.5 Грамматическая нотация
======================

5.1.5.1 Терминальные символы
========================

В грамматиках ECMAScript некоторые терминальные символы выделены шрифтом `фиксированной ширины`. Они должны отображаться в исходном тексте именно так, как они написаны. Все кодовые точки терминальных символов, указанные таким образом, должны пониматься как соответствующие кодовые точки Юникода из блока Basic Latin, а не как любые похожие кодовые точки из других диапазонов Юникода. Кодовая точка в терминальном символе не может быть выражена `\` [UnicodeEscapeSequence](ecmascript-language-lexical-grammar.html#prod-UnicodeEscapeSequence).

В грамматиках, терминальными символами которых являются отдельные кодовые точки Unicode (например, в лексических, RegExp и числовых строковых грамматиках), последовательный ряд из нескольких кодовых точек фиксированной ширины, появляющихся в продукции, является простым сокращением для той же последовательности кодовых точек, записанных как отдельные терминальные символы.

Например, продукция:

[HexIntegerLiteral](notational-conventions.html#prod-grammar-notation-HexIntegerLiteral) :: 0x [HexDigits](ecmascript-language-lexical-grammar.html#prod-HexDigits)

является сокращением для:

[HexIntegerLiteral](notational-conventions.html#prod-grammar-notation-HexIntegerLiteral) :: 0 x [HexDigits](ecmascript-language-lexical-grammar.html#prod-HexDigits)

В отличие от этого, в синтаксической грамматике непрерывный ряд кодовых точек фиксированной ширины является одним терминальным символом.

Терминальные символы бывают двух других видов:

* В лексической грамматике и грамматике RegExp кодовые точки Юникода, не имеющие обычного печатного представления, отображаются в виде "&lt;ABBREV&gt;", где "ABBREV" - это мнемоника для кодовой точки или набора кодовых точек. Эти формы определены в разделах [Unicode Format-Control Characters](ecmascript-language-lexical-grammar.html#sec-unicode-format-control-characters), [White Space](ecmascript-language-lexical-grammar.html#sec-white-space), и [Line Terminators](ecmascript-language-lexical-grammar.html#sec-line-terminators).
* В синтаксической грамматике некоторые терминальные символы (например, [IdentifierName](ecmascript-language-lexical-grammar.html#prod-IdentifierName) и [RegularExpressionLiteral](ecmascript-language-lexical-grammar.html#prod-RegularExpressionLiteral)) выделены курсивом, поскольку они относятся к одноименным нетерминалам в лексической грамматике.

5.1.5.2 Символы нетерминалов и продукций
===========================================

Символы нетерминалов выделены шрифтом _italic_. Определение нетерминала (также называемое "продукцией") вводится именем определяемого нетерминала, за которым следует одно или несколько двоеточий. (Количество двоеточий указывает, к какой грамматике относится данная продукция.) Затем в последующих строках следует одна или несколько альтернативных правых сторон для нетерминала. Например, синтаксическое определение:

[WhileStatement](notational-conventions.html#prod-grammar-notation-WhileStatement) : while ( [Expression](ecmascript-language-expressions.html#prod-Expression) ) [Statement](ecmascript-language-statements-and-declarations.html#prod-Statement)

утверждает, что нетерминал [WhileStatement](notational-conventions.html#prod-grammar-notation-WhileStatement) представляет собой лексему `while`, за которой следует левая скобка, за которой следует лексема [Expression](ecmascript-language-expressions.html#prod-Expression), за которой следует правая скобка, за которой следует [Statement](ecmascript-language-statements-and-declarations.html#prod-Statement). Вхождения [Expression](ecmascript-language-expressions.html#prod-Expression) и [Statement](ecmascript-language-statements-and-declarations.html#prod-Statement) сами по себе являются нетерминалами. В качестве другого примера можно привести синтаксическое определение:

[ArgumentList](notational-conventions.html#prod-grammar-notation-ArgumentList) : [AssignmentExpression](ecmascript-language-expressions.html#prod-AssignmentExpression) [ArgumentList](notational-conventions.html#prod-grammar-notation-ArgumentList) , [AssignmentExpression](ecmascript-language-expressions.html#prod-AssignmentExpression)

гласит, что [ArgumentList](notational-conventions.html#prod-grammar-notation-ArgumentList) может представлять собой либо одно [AssignmentExpression](ecmascript-language-expressions.html#prod-AssignmentExpression), либо [ArgumentList](notational-conventions.html#prod-grammar-notation-ArgumentList), за которым следует запятая, а затем [AssignmentExpression](ecmascript-language-expressions.html#prod-AssignmentExpression). Это определение [ArgumentList](notational-conventions.html#prod-grammar-notation-ArgumentList) является рекурсивным, то есть оно определяется в терминах самого себя. В результате [ArgumentList](notational-conventions.html#prod-grammar-notation-ArgumentList) может содержать любое положительное число аргументов, разделенных запятыми, где каждое выражение аргумента является [AssignmentExpression](ecmascript-language-expressions.html#prod-AssignmentExpression). Такие рекурсивные определения нетерминалов встречаются часто.

5.1.5.3 Необязательные символы
========================

Подстрочный суффикс "opt", который может появляться после терминала или нетерминала, указывает на необязательный символ. Альтернатива, содержащая необязательный символ, фактически задает две правые части: одну, которая опускает необязательный элемент, и другую, которая включает его. Это означает, что:

[VariableDeclaration](notational-conventions.html#prod-grammar-notation-VariableDeclaration) : [BindingIdentifier](ecmascript-language-expressions.html#prod-BindingIdentifier) [Initializer](ecmascript-language-expressions.html#prod-Initializer)opt

является удобным сокращением для:

[VariableDeclaration](notational-conventions.html#prod-grammar-notation-VariableDeclaration) : [BindingIdentifier](ecmascript-language-expressions.html#prod-BindingIdentifier) [BindingIdentifier](ecmascript-language-expressions.html#prod-BindingIdentifier) [Initializer](ecmascript-language-expressions.html#prod-Initializer)

и это:

[ForStatement](notational-conventions.html#prod-grammar-notation-ForStatement) : for ( [LexicalDeclaration](ecmascript-language-statements-and-declarations.html#prod-LexicalDeclaration) [Expression](ecmascript-language-expressions. html#prod-Expression)opt ; [Expression](ecmascript-language-expressions.html#prod-Expression)opt ) [Statement](ecmascript-language-statements-and-declarations.html#prod-Statement)

является удобным сокращением для:

[ForStatement](notational-conventions.html#prod-grammar-notation-ForStatement) : for ( [LexicalDeclaration](ecmascript-language-statements-and-declarations.html#prod-LexicalDeclaration) ; [Expression](ecmascript-language-expressions.html#prod-Expression)opt ) [Statement](ecmascript-language-statements-and-declarations. html#prod-Statement) for ( [LexicalDeclaration](ecmascript-language-statements-and-declarations.html#prod-LexicalDeclaration) [Expression](ecmascript-language-expressions.html#prod-Expression) ; [Expression](ecmascript-language-expressions.html#prod-Expression)opt ) [Statement](ecmascript-language-statements-and-declarations.html#prod-Statement)

что, в свою очередь, является сокращением для:

[ForStatement](notational-conventions.html#prod-grammar-notation-ForStatement) : for ( [LexicalDeclaration](ecmascript-language-statements-and-declarations.html#prod-LexicalDeclaration) ; ) [Statement](ecmascript-language-statements-and-declarations.html#prod-Statement) for ( [LexicalDeclaration](ecmascript-language-statements-and-declarations.html#prod-LexicalDeclaration) ; [Expression](ecmascript-language-expressions.html#prod-Expression) ) [Statement](ecmascript-language-statements-and-declarations.html#prod-Statement) for ( [LexicalDeclaration](ecmascript-language-statements-and-declarations.html#prod-LexicalDeclaration) [Expression](ecmascript-language-expressions.html#prod-Expression) ; ) [Statement](ecmascript-language-statements-and-declarations.html#prod-Statement) for ( [LexicalDeclaration](ecmascript-language-statements-and-declarations.html#prod-LexicalDeclaration) [Expression](ecmascript-language-expressions.html#prod-Expression) ; [Expression](ecmascript-language-expressions.html#prod-Expression) ) [Statement](ecmascript-language-statements-and-declarations.html#prod-Statement)

Таким образом, в данном примере нетерминал [ForStatement](notational-conventions.html#prod-grammar-notation-ForStatement) фактически имеет четыре альтернативные правые стороны.

5.1.5.4 Грамматические параметры
==============================

Продукция может быть параметризована подзаглавной аннотацией вида "\[параметры\]", которая может появляться в качестве суффикса к нетерминальному символу, определяемому продукцией. "Параметры" могут быть как одним именем, так и списком имен, разделенных запятой. Параметризованный продакшн - это сокращение для набора продакшнов, определяющих все комбинации имен параметров, которым предшествует знак подчеркивания и которые добавляются к параметризованному символу нетерминала. Это означает, что:

[StatementList](notational-conventions.html#prod-grammar-notation-StatementList)\[Return\] : [ReturnStatement](ecmascript-language-statements-and-declarations.html#prod-ReturnStatement) [ExpressionStatement](ecmascript-language-statements-and-declarations.html#prod-ExpressionStatement)

является удобным сокращением для:

[StatementList](notational-conventions.html#prod-grammar-notation-StatementList) : [ReturnStatement](ecmascript-language-statements-and-declarations.html#prod-ReturnStatement) [ExpressionStatement](ecmascript-language-statements-and-declarations.html#prod-ExpressionStatement) [StatementList_Return](notational-conventions.html#prod-grammar-notation-StatementList_Return) : [ReturnStatement](ecmascript-language-statements-and-declarations.html#prod-ReturnStatement) [ExpressionStatement](ecmascript-language-statements-and-declarations.html#prod-ExpressionStatement)

и это:

[StatementList](notational-conventions.html#prod-grammar-notation-StatementList)\[Return, In\] : [ReturnStatement](ecmascript-language-statements-and-declarations.html#prod-ReturnStatement) [ExpressionStatement](ecmascript-language-statements-and-declarations.html#prod-ExpressionStatement)

является сокращением для:

[StatementList](notational-conventions.html#prod-grammar-notation-StatementList) : [ReturnStatement](ecmascript-language-statements-and-declarations.html#prod-ReturnStatement) [ExpressionStatement](ecmascript-language-statements-and-declarations.html#prod-ExpressionStatement) [StatementList_Return](notational-conventions.html#prod-grammar-notation-StatementList_Return) : [ReturnStatement](ecmascript-language-statements-and-declarations.html#prod-ReturnStatement) [ExpressionStatement](ecmascript-language-statements-and-declarations.html#prod-ExpressionStatement) [StatementList_In](notational-conventions.html#prod-grammar-notation-StatementList_In) : [ReturnStatement](ecmascript-language-statements-and-declarations.html#prod-ReturnStatement) [ExpressionStatement](ecmascript-language-statements-and-declarations.html#prod-ExpressionStatement) [StatementList\_Return\_In](notational-conventions.html#prod-grammar-notation-StatementList_Return_In) : [ReturnStatement](ecmascript-language-statements-and-declarations.html#prod-ReturnStatement) [ExpressionStatement](ecmascript-language-statements-and-declarations.html#prod-ExpressionStatement)

Несколько параметров создают комбинацию из нескольких продукций, не все из которых обязательно будут упомянуты в полной грамматике.

Ссылки на нетерминалы в правой части продукции также могут быть параметризованы. Например:

[StatementList](notational-conventions.html#prod-grammar-notation-StatementList) : [ReturnStatement](ecmascript-language-statements-and-declarations.html#prod-ReturnStatement) [ExpressionStatement](ecmascript-language-statements-and-declarations.html#prod-ExpressionStatement)\[+In\]

эквивалентно тому, чтобы сказать:

[StatementList](notational-conventions.html#prod-grammar-notation-StatementList) : [ReturnStatement](ecmascript-language-statements-and-declarations.html#prod-ReturnStatement) ExpressionStatement_In

и:

[StatementList](notational-conventions.html#prod-grammar-notation-StatementList) : [ReturnStatement](ecmascript-language-statements-and-declarations.html#prod-ReturnStatement) [ExpressionStatement](ecmascript-language-statements-and-declarations.html#prod-ExpressionStatement)\[~In\]

эквивалентно:

[StatementList](notational-conventions.html#prod-grammar-notation-StatementList) : [ReturnStatement](ecmascript-language-statements-and-declarations.html#prod-ReturnStatement) [ExpressionStatement](ecmascript-language-statements-and-declarations.html#prod-ExpressionStatement)

Нетерминальная ссылка может иметь как список параметров, так и суффикс "opt". Например:

[VariableDeclaration](notational-conventions.html#prod-grammar-notation-VariableDeclaration) : [BindingIdentifier](ecmascript-language-expressions.html#prod-BindingIdentifier) [Initializer](ecmascript-language-expressions.html#prod-Initializer)\[+In\]opt

является сокращением для:

[VariableDeclaration](notational-conventions.html#prod-grammar-notation-VariableDeclaration) : [BindingIdentifier](ecmascript-language-expressions.html#prod-BindingIdentifier) [BindingIdentifier](ecmascript-language-expressions.html#prod-BindingIdentifier) Initializer_In

Префикс имени параметра с "?" в ссылке на нетерминал с правой стороны делает значение параметра зависимым от вхождения имени параметра в ссылку на символ с левой стороны текущей продукции. Например:

[VariableDeclaration](notational-conventions.html#prod-grammar-notation-VariableDeclaration)\[In\] : [BindingIdentifier](ecmascript-language-expressions.html#prod-BindingIdentifier) [Initializer](ecmascript-language-expressions.html#prod-Initializer)\[?In\]

это аббревиатура для:

[VariableDeclaration](notational-conventions.html#prod-grammar-notation-VariableDeclaration) : [BindingIdentifier](ecmascript-language-expressions.html#prod-BindingIdentifier) [Initializer](ecmascript-language-expressions.html#prod-Initializer) [VariableDeclaration_In](notational-conventions.html#prod-grammar-notation-VariableDeclaration_In) : [BindingIdentifier](ecmascript-language-expressions.html#prod-BindingIdentifier) Инициализатор_In

Если альтернатива правой стороны имеет префикс "\[+параметр\]", то эта альтернатива доступна только в том случае, если именованный параметр был использован при ссылке на нетерминальный символ продукции. Если правая сторона альтернативы имеет префикс "\[~параметр\]", то эта альтернатива доступна только в том случае, если названный параметр не был использован в ссылке на нетерминальный символ производства. Это означает, что:

[StatementList](notational-conventions.html#prod-grammar-notation-StatementList)\[Return\] : \[+Return\] [ReturnStatement](ecmascript-language-statements-and-declarations.html#prod-ReturnStatement) [ExpressionStatement](ecmascript-language-statements-and-declarations.html#prod-ExpressionStatement)

является сокращением для:

[StatementList](notational-conventions.html#prod-grammar-notation-StatementList) : [ExpressionStatement](ecmascript-language-statements-and-declarations.html#prod-ExpressionStatement) [StatementList_Return](notational-conventions.html#prod-grammar-notation-StatementList_Return) : [ReturnStatement](ecmascript-language-statements-and-declarations.html#prod-ReturnStatement) [ExpressionStatement](ecmascript-language-statements-and-declarations.html#prod-ExpressionStatement)

и это:

[StatementList](notational-conventions.html#prod-grammar-notation-StatementList)\[Return\] : \[~Return\] [ReturnStatement](ecmascript-language-statements-and-declarations.html#prod-ReturnStatement) [ExpressionStatement](ecmascript-language-statements-and-declarations.html#prod-ExpressionStatement)

является сокращением для:

[StatementList](notational-conventions.html#prod-grammar-notation-StatementList) : [ReturnStatement](ecmascript-language-statements-and-declarations.html#prod-ReturnStatement) [ExpressionStatement](ecmascript-language-statements-and-declarations.html#prod-ExpressionStatement) [StatementList_Return](notational-conventions.html#prod-grammar-notation-StatementList_Return) : [ExpressionStatement](ecmascript-language-statements-and-declarations.html#prod-ExpressionStatement)

5.1.5.5 одно из
==============

Когда слова "**один из**" следуют за двоеточием (двоеточиями) в определении грамматики, они означают, что каждый из терминальных символов в следующей строке или строках является альтернативным определением. Например, лексическая грамматика для ECMAScript содержит продукцию:

[NonZeroDigit](notational-conventions.html#prod-grammar-notation-NonZeroDigit) :: одно из 1 2 3 4 5 6 7 8 9

что является просто удобным сокращением для:

[NonZeroDigit](notational-conventions.html#prod-grammar-notation-NonZeroDigit) :: 1 2 3 4 5 6 7 8 9

5.1.5.6 \[empty\]
=================

Если фраза "\[empty\]" появляется в качестве правой части постановки, это означает, что правая часть постановки не содержит терминалов и нетерминалов.

5.1.5.7 Ограничения на будущее
==============================

Если фраза "\[lookahead = seq\]" появляется в правой части продукции, это означает, что данная продукция может быть использована только в том случае, если последовательность токенов seq является префиксом непосредственно следующей за ней входной последовательности токенов. Аналогично, "\[lookahead ∈ set\]", где set - это [конечное](ecmascript-data-types-and-values.html#finite) непустое множество последовательностей токенов, указывает, что данная продукция может быть использована только в том случае, если некоторый элемент set является префиксом непосредственно следующей последовательности токенов. Для удобства набор также может быть записан как нетерминал, в этом случае он представляет собой набор всех последовательностей лексем, до которых этот нетерминал может расшириться. Считается редакционной ошибкой, если нетерминал может расшириться до бесконечно большого количества различных последовательностей лексем.

Эти условия можно отрицать. "\[lookahead ≠ seq\]" указывает, что содержащая продукция может использоваться, только если seq не является префиксом непосредственно следующей входной последовательности лексем, а "\[lookahead ∉ set\]" указывает, что продукция может использоваться, только если _ни один_ элемент множества не является префиксом непосредственно следующей последовательности лексем.

В качестве примера можно привести определения:

[DecimalDigit](notational-conventions.html#prod-grammar-notation-DecimalDigit) :: одно из 0 1 2 3 4 5 6 7 8 9 [DecimalDigits](notational-conventions.html#prod-grammar-notation-DecimalDigits) :: [DecimalDigit](notational-conventions. html#prod-grammar-notation-DecimalDigit) [DecimalDigits](notational-conventions.html#prod-grammar-notation-DecimalDigits) [DecimalDigit](notational-conventions.html#prod-grammar-notation-DecimalDigit)

определение:

[LookaheadExample](notational-conventions.html#prod-grammar-notation-LookaheadExample) :: n \[lookahead ∉ { 1, 3, 5, 7, 9 }\] [DecimalDigits](notational-conventions. html#prod-grammar-notation-DecimalDigits) [DecimalDigit](notational-conventions.html#prod-grammar-notation-DecimalDigit)\[lookahead ∉ [DecimalDigit](notational-conventions.html#prod-grammar-notation-DecimalDigit)\]

соответствует либо букве `n`, за которой следует одна или несколько десятичных цифр, первая из которых четная, либо десятичной цифре, за которой не следует другая десятичная цифра.

Обратите внимание, что при использовании этих фраз в синтаксической грамматике может оказаться невозможным однозначно идентифицировать непосредственно следующую последовательность лексем, поскольку для определения последующих лексем требуется знать, какой лексический [символ цели](notational-conventions.html#sec-context-free-grammars) использовать в последующих позициях. Поэтому, когда они используются в синтаксической грамматике, считается редакционной ошибкой, если последовательность лексем seq появляется в ограничении просмотра (в том числе как часть набора последовательностей), если выбор лексических [символов цели](notational-conventions.html#sec-context-free-grammars) для использования может изменить, будет ли seq префиксом результирующей последовательности лексем или нет.

5.1.5.8 \[нет [LineTerminator](ecmascript-language-lexical-grammar.html#prod-LineTerminator) здесь\]
==================================================================================================

Если фраза "\[no [LineTerminator](ecmascript-language-lexical-grammar.html#prod-LineTerminator) here\]" появляется в правой части продукции синтаксической грамматики, это указывает, что данная продукция является _ограниченной_: она не может быть использована, если во входном потоке в указанной позиции встречается [LineTerminator](ecmascript-language-lexical-grammar.html#prod-LineTerminator). Например:

[ThrowStatement](notational-conventions.html#prod-grammar-notation-ThrowStatement) : throw \[no [LineTerminator](ecmascript-language-lexical-grammar.html#prod-LineTerminator) here\] [Выражение](ecmascript-language-expressions.html#prod-Expression) ;

указывает, что производство не может быть использовано, если между маркером `throw` и [Expression](ecmascript-language-expressions.html#prod-Expression) в скрипте встречается [LineTerminator](ecmascript-language-expressions.html#prod-Expression).

Если присутствие [LineTerminator](ecmascript-language-lexical-grammar.html#prod-LineTerminator) не запрещено ограниченным производством, любое количество вхождений [LineTerminator](ecmascript-language-lexical-grammar.html#prod-LineTerminator) может появляться между любыми двумя последовательными токенами в потоке входных элементов без ущерба для синтаксической приемлемости скрипта.

5.1.5.9 но не
===============

Правая часть продукции может указывать, что определенные расширения не разрешены, используя фразу "**но не**", а затем указывая расширения, которые должны быть исключены. Например, производство:

[Identifier](notational-conventions.html#prod-grammar-notation-Identifier) :: [IdentifierName](ecmascript-language-lexical-grammar.html#prod-IdentifierName), но не [ReservedWord](ecmascript-language-lexical-grammar.html#prod-ReservedWord)

означает, что нетерминал [Identifier](notational-conventions.html#prod-grammar-notation-Identifier) может быть заменен любой последовательностью точек кода, которая может заменить [IdentifierName](ecmascript-language-lexical-grammar.html#prod-IdentifierName) при условии, что та же самая последовательность точек кода не может заменить [ReservedWord](ecmascript-language-lexical-grammar.html#prod-ReservedWord).

5.1.5.10 Описательные фразы
============================

Наконец, несколько нетерминальных символов описываются описательной фразой, набранной шрифтом sans-serif, в случаях, когда перечисление всех альтернатив нецелесообразно:

[SourceCharacter](notational-conventions.html#prod-grammar-notation-SourceCharacter) :: любая точка кода Unicode

5.2 Условные обозначения алгоритмов
=========================

В спецификации часто используется нумерованный список для указания шагов в алгоритме. Эти алгоритмы используются для точного определения требуемой семантики конструкций языка ECMAScript. Алгоритмы не подразумевают использование какой-либо конкретной техники реализации. На практике могут существовать более эффективные алгоритмы для реализации той или иной функции.

Алгоритмы могут быть явно параметризованы с помощью упорядоченной последовательности имен псевдонимов, разделенных запятыми, которые могут быть использованы в рамках шагов алгоритма для ссылки на аргумент, переданный в данной позиции. Необязательные параметры обозначаются окружающими скобками (\[ , имя \]) и не отличаются от обязательных параметров в шагах алгоритма. В конце списка параметров может появиться параметр rest, обозначаемый многоточием (, ...name). Параметр rest собирает в [List](ecmascript-data-types-and-values.html#sec-list-and-record-specification-type) все аргументы, предоставленные после обязательных и необязательных параметров. Если таких дополнительных аргументов нет, то [List](ecmascript-data-types-and-values.html#sec-list-and-record-specification-type) пуст.

Шаги алгоритма могут быть разделены на последовательные подшаги. Подэтапы имеют отступы и сами могут делиться на подэтапы с отступами. Для идентификации подэтапов используются условные обозначения, при этом первый уровень подэтапов обозначается строчными алфавитными символами, а второй уровень подэтапов - строчными римскими цифрами. Если требуется более трех уровней, эти правила повторяются и для четвертого уровня с использованием цифровых обозначений. Например:

1.  1\. Шаг верхнего уровня
    1. a. Подшаг.
    2. b. Подшаг.
        1. i. Подшаг.
            1.  1\. Subsubsubstep
                1. a. Субсубстеп
                    1. i. Subsubsubsubstep

Шаг или подшаг может быть записан как предикат "если", который обуславливает его подшаги. В этом случае подшаги применяются только в том случае, если предикат истинен. Если шаг или подшаг начинается со слова "else", это предикат, который является отрицанием предыдущего шага предиката "if" на том же уровне.

Шаг может определять итеративное применение своих подшагов.

Шаг, начинающийся с "Assert:", утверждает неизменное условие алгоритма. Такие утверждения используются для того, чтобы сделать явными алгоритмические инварианты, которые в противном случае были бы неявными. Такие утверждения не добавляют никаких дополнительных семантических требований и, следовательно, не нуждаются в проверке со стороны реализации. Они используются просто для прояснения алгоритмов.

Шаги алгоритма могут объявлять именованные псевдонимы для любого значения, используя форму "Пусть x будет someValue". Эти псевдонимы являются ссылочными в том смысле, что и x, и someValue ссылаются на одни и те же базовые данные, и модификации одного из них видны обоим. Шаги алгоритма, которые хотят избежать такого ссылочно-подобного поведения, должны явно создавать копию правой стороны: "Пусть x будет копией someValue" создает неглубокую копию someValue.

После объявления псевдонима на него можно ссылаться в любых последующих шагах, и на него нельзя ссылаться в шагах, предшествующих объявлению псевдонима. Псевдонимы могут быть изменены с помощью формы "Set x to someOtherValue".

5.2.1 Абстрактные операции
=========================

Чтобы облегчить их использование во многих частях данной спецификации, некоторые алгоритмы, называемые абстрактными операциями, названы и записаны в параметризованной функциональной форме, чтобы на них можно было ссылаться по имени из других алгоритмов. Ссылки на абстрактные операции обычно используются в стиле функционального приложения, например OperationName(arg1, arg2). Некоторые абстрактные операции рассматриваются как полиморфно диспетчеризуемые методы классоподобных спецификационных абстракций. На такие абстрактные операции, похожие на методы, обычно ссылаются, используя стиль применения метода, например someValue.OperationName(arg1, arg2).

5.2.2 Операции, ориентированные на синтаксис
================================

Синтаксически направленная операция - это именованная операция, определение которой состоит из алгоритмов, каждый из которых связан с одной или несколькими продукциями из одной из грамматик ECMAScript. Продукция, имеющая несколько альтернативных определений, обычно имеет отдельный алгоритм для каждой альтернативы. Когда алгоритм связан с грамматической продукцией, он может ссылаться на терминальные и нетерминальные символы альтернативной продукции, как если бы они были параметрами алгоритма. При таком использовании нетерминальные символы относятся к реальному определению альтернативы, которое сопоставляется при разборе исходного текста. Исходный текст, которому соответствует грамматическая продукция или [Parse Node](notational-conventions.html#sec-syntactic-grammar), полученная из нее, - это часть исходного текста, которая начинается в начале первого терминала, участвовавшего в согласовании, и заканчивается в конце последнего терминала, участвовавшего в согласовании.

Когда алгоритм связан с производственной альтернативой, эта альтернатива обычно показывается без каких-либо грамматических аннотаций "\[ \]". Такие аннотации должны влиять только на синтаксическое распознавание альтернативы и не влиять на связанную с ней семантику.

Синтаксически направленные операции вызываются с узлом разбора и, опционально, другими параметрами, используя соглашения на шагах [1](notational-conventions.html#step-sdo-invocation-example-1), [3](notational-conventions.html#step-sdo-invocation-example-2) и [4](notational-conventions.html#step-sdo-invocation-example-3) в следующем алгоритме:

1.  1\. Пусть status - SyntaxDirectedOperation некоторогоNonTerminal.
2.  2\. Пусть someParseNode - это разбор некоторого исходного текста.
3.  3\. Выполнить операцию SyntaxDirectedOperation над someParseNode.
4.  4\. Выполнить SyntaxDirectedOperation someParseNode с аргументом "value".

Если явно не указано иное, все [цепные продукции](notational-conventions.html#sec-context-free-grammars) имеют неявное определение для каждой операции, которая может быть применена к левостороннему нетерминалу этой продукции. Неявное определение просто повторно применяет ту же операцию с теми же параметрами, если таковые имеются, к единственному правостороннему нетерминалу [chain production](notational-conventions.html#sec-context-free-grammars), а затем возвращает результат. Например, предположим, что в некотором алгоритме есть шаг вида: "Вернуть [Evaluation](syntax-directed-operations.html#sec-evaluation) из [Block](ecmascript-language-statements-and-declarations.html#prod-Block)" и что существует продукция:

[Block](ecmascript-language-statements-and-declarations.html#prod-Block) : { [StatementList](ecmascript-language-statements-and-declarations.html#prod-StatementList) }

но операция [Evaluation](syntax-directed-operations.html#sec-evaluation) не связывает алгоритм с этой продукцией. В этом случае операция [Evaluation](syntax-directed-operations.html#sec-evaluation) неявно включает ассоциацию вида:

** Семантика времени выполнения: [Evaluation](syntax-directed-operations.html#sec-evaluation)**.

[Блок](ecmascript-language-statements-and-declarations.html#prod-Block) : { [StatementList](ecmascript-language-statements-and-declarations.html#prod-StatementList)}

1.  1\. Возвращает [Evaluation](syntax-directed-operations.html#sec-evaluation) из [StatementList](ecmascript-language-statements-and-declarations.html#prod-StatementList).

5.2.3 Семантика времени выполнения
=======================

Алгоритмы, определяющие семантику, которая должна быть вызвана во время выполнения, называются семантикой времени выполнения. Семантика времени выполнения определяется [абстрактными операциями](notational-conventions.html#sec-algorithm-conventions-abstract-operations) или [синтаксически-направленными операциями](notational-conventions.html#sec-algorithm-conventions-syntax-directed-operations).

5.2.3.1 Завершение ( completionRecord )
=======================================

Абстрактная операция Completion принимает аргумент completionRecord (запись [Completion Record](ecmascript-data-types-and-values.html#sec-completion-record-specification-type)) и возвращает запись [Completion Record](ecmascript-data-types-and-values.html#sec-completion-record-specification-type). Используется, чтобы подчеркнуть, что возвращается [Completion Record](ecmascript-data-types-and-values.html#sec-completion-record-specification-type). При его вызове выполняются следующие действия:

1.  1\. [Утверждение](notational-conventions.html#assert): completionRecord является [Completion Record](ecmascript-data-types-and-values.html#sec-completion-record-specification-type).
2.  2\. Вернуть completionRecord.

5.2.3.2 Выбросить исключение
==========================

Шаги алгоритма, в которых говорится о необходимости выбросить исключение, такие как

1.  1\. Выбросить исключение TypeError.

означают то же самое, что и:

1.  1\. Возвращает [ThrowCompletion](ecmascript-data-types-and-values.html#sec-throwcompletion)(только что созданный объект TypeError).

5.2.3.3 ReturnIfAbrupt
======================

Шаги алгоритма, которые говорят или эквивалентны иным образом:

1.  1\. [ReturnIfAbrupt](notational-conventions.html#sec-returnifabrupt)(argument).

означают то же самое, что и:

1.  1\. [Assert](notational-conventions.html#assert): argument is a [Completion Record](ecmascript-data-types-and-values.html#sec-completion-record-specification-type).
2.  2\. Если аргумент является [резким завершением](ecmascript-data-types-and-values.html#sec-completion-record-specification-type), возвращаем [Завершение](notational-conventions.html#sec-completion-ao)(аргумент).
3.  3\. Иначе, установите аргумент в аргумент.\[\[Value\]\].

Шаги алгоритмов, которые говорят или эквивалентны иным образом:

1.  1\. [ReturnIfAbrupt](notational-conventions.html#sec-returnifabrupt)(AbstractOperation()).

означают то же самое, что:

1.  1\. Пусть hygienicTemp - это AbstractOperation().
2.  2\. [Assert](notational-conventions.html#assert): hygienicTemp is a [Completion Record](ecmascript-data-types-and-values.html#sec-completion-record-specification-type).
3.  3\. Если hygienicTemp является [резким завершением](ecmascript-data-types-and-values.html#sec-completion-record-specification-type), верните [Завершение](notational-conventions.html#sec-completion-ao)(hygienicTemp).
4.  4\. Иначе, установите hygienicTemp в hygienicTemp.\[\[Value\]\].

Где hygienicTemp является эфемерным и виден только в шагах, относящихся к ReturnIfAbrupt.

Шаги алгоритма, которые говорят или иным образом эквивалентны:

1.  1\. Пусть result будет AbstractOperation([ReturnIfAbrupt](notational-conventions.html#sec-returnifabrupt)(argument)).

означает то же самое, что:

1.  1\. [Assert](notational-conventions.html#assert): argument is a [Completion Record](ecmascript-data-types-and-values.html#sec-completion-record-specification-type).
2.  2\. Если аргумент является [резким завершением](ecmascript-data-types-and-values.html#sec-completion-record-specification-type), возвращаем [Завершение](notational-conventions.html#sec-completion-ao)(аргумент).
3.  3\. Иначе, установите аргумент в argument.\[\[Value\]\].
4.  4\. Пусть result будет AbstractOperation(argument).

5.2.3.4 Сокращения ReturnIfAbrupt
=================================

Вызовы [абстрактных операций](notational-conventions.html#sec-algorithm-conventions-abstract-operations) и [синтаксически-направленных операций](notational-conventions.html#sec-algorithm-conventions-syntax-directed-operations), которые имеют префикс `? ` указывают, что к результирующей [Completion Record](ecmascript-data-types-and-values.html#sec-completion-record-specification-type) следует применить [ReturnIfAbrupt](notational-conventions.html#sec-returnifabrupt). Например, шаг:

1.  1\. ? OperationName().

эквивалентен следующему шагу:

1.  1\. [ReturnIfAbrupt](notational-conventions.html#sec-returnifabrupt)(OperationName()).

Аналогично, для стиля применения метода шаг:

1.  1\. ? someValue.OperationName().

эквивалентен:

1.  1\. [ReturnIfAbrupt](notational-conventions.html#sec-returnifabrupt)(someValue.OperationName()).

Аналогично, префикс `!` используется для указания на то, что следующий вызов абстрактной или [синтаксически направленной операции](notational-conventions.html#sec-algorithm-conventions-syntax-directed-operations) никогда не вернет [резкое завершение](ecmascript-data-types-and-values. html#sec-completion-record-specification-type) и что результирующее поле [Completion Record](ecmascript-data-types-and-values.html#sec-completion-record-specification-type)\[\[Value\]\] должно быть использовано вместо возвращаемого значения операции. Например, шаг:

1.  1\. Пусть val будет ! OperationName().

эквивалентен следующим шагам:

1.  1\. Пусть val будет OperationName().
2.  2\. [Assert](notational-conventions.html#assert): val is a [normal completion](ecmascript-data-types-and-values.html#sec-completion-record-specification-type).
3.  3\. Установить val в val.\[\[Value\]\].

В [Синтаксических операциях](notational-conventions.html#sec-algorithm-conventions-syntax-directed-operations) для [Семантики времени выполнения](notational-conventions.html#sec-runtime-semantics) используется это сокращение путем размещения `!` или `?` перед вызовом операции:

1.  1\. Выполнить ! СинтаксисНаправленнаяОперацияНеТерминала.

5.2.3.5 Неявное нормальное завершение
==================================

В алгоритмах в рамках [абстрактных операций](notational-conventions.html#sec-algorithm-conventions-abstract-operations), которые объявлены как возвращающие [Completion Record](ecmascript-data-types-and-values.html#sec-completion-record-specification-type), и во всех встроенных функциях, возвращаемое значение сначала передается в [NormalCompletion](ecmascript-data-types-and-values.html#sec-normalcompletion), а результат используется вместо него. Это правило не применяется в рамках алгоритма [Completion](notational-conventions.html#sec-completion-ao) или когда возвращаемое значение явно помечено как [Completion Record](ecmascript-data-types-and-values.html#sec-completion-record-specification-type) на этом шаге; к таким случаям относятся:

* когда непосредственно возвращается результат применения [Completion](notational-conventions.html#sec-completion-ao), [NormalCompletion](ecmascript-data-types-and-values.html#sec-normalcompletion) или [ThrowCompletion](ecmascript-data-types-and-values.html#sec-throwcompletion)
* когда непосредственно возвращается результат построения [Completion Record](ecmascript-data-types-and-values.html#sec-completion-record-specification-type)

Это редакционная ошибка, если [Completion Record](ecmascript-data-types-and-values.html#sec-completion-record-specification-type) возвращается из такой абстрактной операции любым другим способом. Например, в рамках этих [абстрактных операций](notational-conventions.html#sec-algorithm-conventions-abstract-operations),

1.  1\. Возвращает true.

означает то же самое, что и любая из

1.  1\. Возвращает [NormalCompletion](ecmascript-data-types-and-values.html#sec-normalcompletion)(true).

или

1.  1\. Пусть завершение будет [NormalCompletion](ecmascript-data-types-and-values.html#sec-normalcompletion)(true).
2.  2\. Возвращаем [Completion](notational-conventions.html#sec-completion-ao)(completion).

или

1.  1\. Возвращается [Запись завершения](ecmascript-data-types-and-values.html#sec-completion-record-specification-type) { \[\[Type\]\]: normal, \[\[Value\]\]: true, \[\[Target\]\]: empty }.

Обратите внимание, что благодаря расширению [ReturnIfAbrupt](notational-conventions.html#sec-returnifabrupt) следующий пример допустим, поскольку в рамках расширенных шагов результат применения [Completion](notational-conventions.html#sec-completion-ao) возвращается непосредственно в прерывистом случае, а неявное применение [NormalCompletion](ecmascript-data-types-and-values.html#sec-normalcompletion) происходит после разворачивания в нормальном случае.

1.  1\. Возврат ? завершение.

Следующий пример будет редакционной ошибкой, потому что возвращается [Completion Record](ecmascript-data-types-and-values.html#sec-completion-record-specification-type) без аннотации на этом шаге.

1.  1\. Пусть завершение будет [NormalCompletion](ecmascript-data-types-and-values.html#sec-normalcompletion)(true).
2.  2\. Вернуть завершение.

5.2.4 Статическая семантика
======================

Контекстно-свободные грамматики недостаточно мощны, чтобы выразить все правила, определяющие, образует ли поток входных элементов допустимый ECMAScript [Script](ecmascript-language-scripts-and-modules.html#prod-Script) или [Module](ecmascript-language-scripts-and-modules.html#prod-Module), который может быть оценен. В некоторых ситуациях требуются дополнительные правила, которые могут быть выражены либо с помощью соглашений алгоритмов ECMAScript, либо с помощью прозаических требований. Такие правила всегда связаны с продукцией грамматики и называются статической семантикой этой продукции.

Статические семантические правила имеют имена и обычно определяются с помощью алгоритма. Именованные статические семантические правила ассоциируются с грамматическими продукциями, и продукция, имеющая несколько альтернативных определений, обычно имеет для каждой альтернативы отдельный алгоритм для каждого применимого именованного статического семантического правила.

Особым видом статического семантического правила является правило ранней ошибки. Правила [Early error](error-handling-and-language-extensions.html#early-error) определяют условия [Early error](error-handling-and-language-extensions.html#early-error) (см. пункт [17](error-handling-and-language-extensions.html#sec-error-handling-and-language-extensions)), которые связаны с конкретными грамматическими постановками. [Оценка](syntax-directed-operations.html#sec-evaluation) большинства правил [ранней ошибки](error-handling-and-language-extensions.html#early-error) не вызывается явно в рамках алгоритмов данной спецификации. Соответствующая реализация должна перед первой оценкой [Скрипта](ecmascript-language-scripts-and-modules.html#prod-Script) или [Модуля](ecmascript-language-scripts-and-modules.html#prod-Module) проверять все [ранние ошибки](error-handling-and-language-extensions. html#early-error) правил производств, используемых для разбора этого [Скрипта](ecmascript-language-scripts-and-modules.html#prod-Script) или [Модуля](ecmascript-language-scripts-and-modules.html#prod-Module). При нарушении любого из правил [early error](error-handling-and-language-extensions.html#early-error) [Script](ecmascript-language-scripts-and-modules.html#prod-Script) или [Module](ecmascript-language-scripts-and-modules.html#prod-Module) является недействительным и не может быть оценен.

5.2.5 Математические операции
=============================

В данной спецификации упоминаются такие виды числовых значений:

* Математические значения: Произвольные вещественные числа, используемые в качестве числового типа по умолчанию.
* Расширенные математические значения: [Математические значения](notational-conventions.html#mathematical-value) вместе с +∞ и -∞.
* _Числа_: [IEEE 754-2019](bibliography.html#sec-bibliography) двоичные64 (с плавающей точкой двойной точности) значения.
* _BigInts_: [значения языка ECMAScript](ecmascript-data-types-and-values.html#sec-ecmascript-language-types), представляющие произвольные [целые числа](notational-conventions.html#integer) в соответствии один к одному.

В языке данной спецификации числовые значения различаются между различными числовыми видами с помощью суффиксов субскриптов. Подскрипт 𝔽 относится к числам, а подскрипт ℤ - к BigInts. Числовые значения без суффикса подписи относятся к [математическим значениям](notational-conventions.html#mathematical-value). В данной спецификации большинство числовых значений обозначается по основанию 10; также используются числовые значения вида 0x с последующими цифрами 0-9 или A-F как значения по основанию 16.

В общем случае, когда данная спецификация ссылается на числовое значение, например, во фразе "длина y" или "[целое число](notational-conventions.html#integer), представленное четырьмя шестнадцатеричными цифрами ...", без явного указания числового вида, фраза ссылается на [математическое значение](notational-conventions.html#mathematical-value). Фразы, относящиеся к числу или значению BigInt, явно аннотируются как таковые; например, "[числовое значение для](ecmascript-data-types-and-values.html#number-value-for) количества точек кода в ..." или "значение [BigInt для](notational-conventions.html#bigint-value-for) ...".

Когда термин integer используется в данной спецификации, он относится к [математическому значению](notational-conventions.html#mathematical-value), которое находится в наборе [целых чисел](notational-conventions.html#integer), если не указано иное. Когда в данной спецификации используется термин "целое число", он относится к значению числа, чье [математическое значение](notational-conventions.html#mathematical-value) находится в множестве [целых чисел](notational-conventions.html#integer).

Числовые операторы, такие как +, ×, = и ≥, относятся к тем операциям, которые определяются типом операндов. При применении к [математическим значениям](notational-conventions.html#mathematical-value) операторы относятся к обычным математическим операциям. При применении к [расширенным математическим значениям](notational-conventions.html#extended-mathematical-value) операторы относятся к обычным математическим операциям над расширенными вещественными числами; неопределенные формы не определены, и их использование в данной спецификации следует считать редакционной ошибкой. При применении к Numbers операторы ссылаются на соответствующие операции в [IEEE 754-2019](bibliography.html#sec-bibliography). При применении к BigInts операторы относятся к обычным математическим операциям, применяемым к [математическому значению](notational-conventions.html#mathematical-value-of) BigInt. Числовые операторы, применяемые к операндам смешанного типа (таким как число и [математическое значение](notational-conventions.html#mathematical-value)), не определены и должны рассматриваться как редакционная ошибка в данной спецификации.

Преобразования между [математическими значениями](notational-conventions.html#mathematical-value) и числами или BigInts всегда явно выражены в этом документе. Преобразование из [математического значения](notational-conventions.html#mathematical-value) или [расширенного математического значения](notational-conventions.html#extended-mathematical-value) x в Число обозначается как "значение [Число для](ecmascript-data-types-and-values. html#number-value-for) x" или 𝔽(x), и определяется в [6.1.6.1](ecmascript-data-types-and-values.html#sec-ecmascript-language-types-number-type). Преобразование из [целого числа](notational-conventions.html#integer) x в BigInt обозначается как "значение BigInt для x" или ℤ(x). Преобразование числа или BigInt x в [математическое значение](notational-conventions.html#mathematical-value) обозначается как "математическое значение x", или ℝ(x). Математическое значение](notational-conventions.html#mathematical-value-of) +0𝔽 и -0𝔽 - это [математическое значение](notational-conventions.html#mathematical-value) 0\. [Математическое значение](notational-conventions.html#mathematical-value-of) не[конечных](ecmascript-data-types-and-values.html#finite) величин не определено. Расширенное математическое значение x - это [математическое значение](notational-conventions.html#mathematical-value-of) x для [конечных](ecmascript-data-types-and-values.html#finite) значений, и равно +∞ и -∞ для +∞𝔽 и -∞𝔽 соответственно; для NaN оно не определено.

Математическая функция abs(x) выдает абсолютное значение x, которое равно -x, если x < 0, а в противном случае равно самому x.

Математическая функция min(x1, x2, ... , xN) выдает математически наименьшее из x1 - xN. Математическая функция max(x1, x2, ..., xN) производит математически наибольшее из x1 - xN. Область и диапазон этих математических функций являются [расширенными математическими значениями](notational-conventions.html#extended-mathematical-value).

Выражение "x по модулю y" (y должен быть [конечным](ecmascript-data-types-and-values.html#finite) и ненулевым) вычисляет значение k того же знака, что и y (или нуль), такое, что [abs](notational-conventions.html#eqn-abs)(k) < [abs](notational-conventions.html#eqn-abs)(y) и x \- k = q × y для некоторого [целого](notational-conventions.html#integer) q.

Фраза "результат зажатия x между нижним и верхним" (где x - это [расширенное математическое значение](notational-conventions.html#extended-mathematical-value), а нижнее и верхнее - [математические значения](notational-conventions.html#mathematical-value) такие, что нижнее ≤ верхнее) производит нижнее, если x < нижнего, производит верхнее, если x \> верхнего, и иначе производит x.

Математическая функция floor(x) выдает наибольшее [целое число](notational-conventions.html#integer) (ближайшее к +∞), которое не больше x.

Примечание

[floor](notational-conventions.html#eqn-floor)(x) = x \- (x [modulo](notational-conventions.html#eqn-modulo) 1).

Математическая функция truncate(x) удаляет дробную часть x путем округления в сторону нуля, выдавая -[floor](notational-conventions.html#eqn-floor)(-x), если x < 0, и [floor](notational-conventions.html#eqn-floor)(x) в противном случае.

Математические функции [min](notational-conventions.html#eqn-min), [max](notational-conventions.html#eqn-max), [abs](notational-conventions.html#eqn-abs), [floor](notational-conventions.html#eqn-floor) и [truncate](notational-conventions. html#eqn-truncate) не определены для Numbers и BigInts, и любое использование этих методов с аргументами не [mathematical value](notational-conventions.html#mathematical-value) было бы редакционной ошибкой в данной спецификации.

Интервал от нижней границы a до верхней границы b - это возможно бесконечное, возможно пустое множество числовых значений одного и того же числового типа. Каждая граница описывается как включающая или исключающая, но не как обе. Существует четыре вида интервалов, а именно:

* [интервал](notational-conventions.html#interval) от a (включительно) до b (включительно), также называемый инклюзивным интервалом от a до b, включает все значения x одного числового типа такие, что a ≤ x ≤ b, и никакие другие.
* [интервал](notational-conventions.html#interval) от a (inclusive) до b (exclusive) включает все значения x одного и того же числового типа такие, что a ≤ x < b, и никакие другие.
* [интервал](notational-conventions.html#interval) от a (включительно) до b (включительно) включает все значения x одного числового типа, такие что a < x ≤ b, и никакие другие.
* [Интервал](notational-conventions.html#interval) от a (исключительный) до b (исключительный) включает все значения x одного и того же числового типа, такие что a < x < b, и никакие другие.

Например, [интервал](notational-conventions.html#interval) от 1 (включительно) до 2 (исключая) состоит из всех [математических значений](notational-conventions.html#mathematical-value) между 1 и 2, включая 1 и не включая 2. Для целей определения интервалов -0𝔽 < +0𝔽, поэтому, например, [инклюзивный интервал](notational-conventions.html#inclusive-interval) с нижней границей +0𝔽 включает +0𝔽, но не -0𝔽. NaN никогда не включается в [интервал](notational-conventions.html#interval).

5.2.6 Условные обозначения значений
====================

В данной спецификации значения [языка ECMAScript](ecmascript-data-types-and-values.html#sec-ecmascript-language-types) выделены жирным шрифтом. В качестве примера можно привести null, true или "hello". Они отличаются от [исходного текста ECMAScript](ecmascript-language-source-code.html#sec-source-text), таких как `Function.prototype.apply` или `let n = 42;`.

5.2.7 Идентичность
==============

В данной спецификации значения спецификации и [значения языка ECMAScript] (ecmascript-data-types-and-values.html#sec-ecmascript-language-types) сравниваются на равенство. При сравнении на равенство значения попадают в одну из двух категорий. Значения без идентичности равны другим значениям без идентичности, если все их врожденные характеристики одинаковы - такие характеристики, как величина [integer](notational-conventions.html#integer) или длина последовательности. Значения, не обладающие идентичностью, могут быть явлены без предварительного упоминания путем полного описания их характеристик. В отличие от этого, каждое значение с тождеством уникально и поэтому равно только самому себе. Значения с тождественностью подобны значениям без тождественности, но имеют дополнительную не поддающуюся определению, неизменную, универсально уникальную характеристику, называемую _тождественностью_. Ссылки на существующие значения с идентичностью не могут быть явлены простым описанием, поскольку сама идентичность неописуема; вместо этого ссылки на эти значения должны быть явно переданы из одного места в другое. Некоторые значения с идентичностью являются мутабельными и поэтому могут изменять свои характеристики (кроме идентичности) на месте, в результате чего все владельцы значения будут наблюдать новые характеристики. Значение без идентичности никогда не равно значению с идентичностью.

С точки зрения данной спецификации, слово "is" используется для сравнения двух значений на равенство, как в "If bool is true, then ...", а слово "contains" используется для поиска значения внутри списков с использованием сравнения на равенство, как в "If list contains a [Record](ecmascript-data-types-and-values.html#sec-list-and-record-specification-type) r such that r.\[\[Foo\]\] is true, then ...". Тождество _спецификации_ значений определяет результат этих сравнений и является аксиомой в данной спецификации.

С точки зрения языка ECMAScript, языковые значения сравниваются на равенство с помощью абстрактной операции [SameValue](abstract-operations.html#sec-samevalue) и транзитивно вызываемых ею [abstract operations](notational-conventions.html#sec-algorithm-conventions-abstract-operations). Алгоритмы этих сравнительных [абстрактных операций](notational-conventions.html#sec-algorithm-conventions-abstract-operations) определяют _языковую идентичность_ значений [языка ECMAScript](ecmascript-data-types-and-values.html#sec-ecmascript-language-types).

Для спецификационных значений примеры значений без спецификационной идентичности включают, но не ограничиваются ими: [математические значения](notational-conventions.html#mathematical-value) и [расширенные математические значения](notational-conventions.html#extended-mathematical-value); [исходный текст ECMAScript](ecmascript-language-source-code.html#sec-source-text), [суррогатные пары](ecmascript-data-types-and-values.html#surrogate-pair), [прологи директивы](ecmascript-language-source-code. html#directive-prologue) и т. д.; кодовые единицы UTF-16; кодовые точки Unicode; [перечисления](ecmascript-data-types-and-values.html#sec-enum-specification-type); [абстрактные операции](notational-conventions. html#sec-algorithm-conventions-abstract-operations), включая [синтаксически-направленные операции](notational-conventions.html#sec-algorithm-conventions-syntax-directed-operations), [host hooks](overview.html#host-hook) и т. д.; и упорядоченные пары. Примеры значений спецификации с идентичностью спецификации включают, но не ограничиваются ими: любые виды [Записей](ecmascript-data-types-and-values.html#sec-list-and-record-specification-type), включая [Дескрипторы свойств](ecmascript-data-types-and-values.html#sec-property-descriptor-specification-type), [PrivateElements](ecmascript-data-types-and-values. html#sec-privateelement-specification-type) и т.д.; [Parse Nodes](notational-conventions.html#sec-syntactic-grammar); [Lists](ecmascript-data-types-and-values.html#sec-list-and-record-specification-type); [Sets](ecmascript-data-types-and-values.html#sec-set-and-relation-specification-type) и [Relations](ecmascript-data-types-and-values. html#sec-set-and-relation-specification-type); [Абстрактные закрытия](ecmascript-data-types-and-values.html#sec-abstract-closure); [Блоки данных](ecmascript-data-types-and-values.html#sec-data-blocks); [Частные имена](ecmascript-data-types-and-values.html#sec-private-names); [Контексты выполнения](executable-code-and-execution-contexts. html#sec-execution-contexts) и [стеки контекстов выполнения](executable-code-and-execution-contexts.html#execution-context-stack); [агенты-сигнификаторы](executable-code-and-execution-contexts.html#sec-agents); и [записи списков ожидания](structured-data.html#sec-waiterlist-records).

Идентичность спецификации согласуется с идентичностью языка для всех значений языка [ECMAScript](ecmascript-data-types-and-values.html#sec-ecmascript-language-types), кроме значений Symbol, создаваемых [Symbol.for](fundamental-objects.html#sec-symbol.for). Значения языка [ECMAScript](ecmascript-data-types-and-values.html#sec-ecmascript-language-types) без идентификации спецификации и без идентификации языка являются [неопределенными](ecmascript-data-types-and-values. html#sec-ecmascript-language-types-undefined-type), [null](ecmascript-data-types-and-values.html#sec-ecmascript-language-types-null-type), [Booleans](ecmascript-data-types-and-values. html#sec-ecmascript-language-types-boolean-type), [Строки](ecmascript-data-types-and-values.html#sec-ecmascript-language-types-string-type), [Числа](ecmascript-data-types-and-values. html#sec-ecmascript-language-types-number-type), и [BigInts](ecmascript-data-types-and-values.html#sec-ecmascript-language-types-bigint-type). Значениями языка [ECMAScript](ecmascript-data-types-and-values.html#sec-ecmascript-language-types) с идентичностью спецификации и идентичностью языка являются [Symbols](ecmascript-data-types-and-values. html#sec-ecmascript-language-types-symbol-type), не порождаемые [Symbol.for](fundamental-objects.html#sec-symbol.for) и [Objects](ecmascript-data-types-and-values.html#sec-object-type). Значения символов, созданные с помощью [Symbol.for](fundamental-objects.html#sec-symbol.for), обладают идентичностью спецификации, но не идентичностью языка.
